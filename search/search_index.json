{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Hishel - An elegant HTTP Cache implementation for httpx and httpcore.</p> <p> </p> <p> </p> <p>Hishel (\u0570\u056b\u0577\u0565\u056c, remember) is a library that implements HTTP Caching for HTTPX and HTTP Core libraries in accordance with RFC 9111, the most recent caching specification.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Persistence: Responses are cached in the persistent memory for later use.</li> <li> Compatibility: It is completely compatible with your existing transports or connection pools, whether they are default, custom, or provided by third-party libraries.</li> <li> Easy to use: You continue to use httpx while also enabling web cache.</li> <li> Smart: Attempts to clearly implement RFC 9111, understands <code>Vary</code>, <code>Etag</code>, <code>Last-Modified</code>,  <code>Cache-Control</code>, and <code>Expires</code> headers, and handles response re-validation automatically.</li> <li> Configurable: You have complete control over how the responses are stored and serialized.</li> <li> From the package:<ul> <li>Built-in support for File system  , Redis , SQLite  , and AWS S3  backends.</li> <li>Built-in support for JSON  , YAML , and pickle serializers.</li> </ul> </li> <li> Very fast: Your requests will be even faster if there are no IO operations.</li> </ul>"},{"location":"#quickstart","title":"QuickStart","text":"<p>Install <code>Hishel</code> using pip: <pre><code>$ pip install hishel\n</code></pre></p> <p>Let's begin with an example of a httpx client.</p> <pre><code>import hishel\n\nwith hishel.CacheClient() as client:\n    client.get(\"https://hishel.com\")  # 0.4749558370003797s\n    client.get(\"https://hishel.com\")  # 0.002873589000046195s (~250x faster!)\n</code></pre> <p>or in asynchronous context</p> <pre><code>import hishel\n\nasync with hishel.AsyncCacheClient() as client:\n    await client.get(\"https://hishel.com\")\n    await client.get(\"https://hishel.com\")  # takes from the cache\n</code></pre>"},{"location":"#configurations","title":"Configurations","text":"<p>Configure when and how you want to store your responses.</p> <pre><code>import hishel\n\n# All the specification configs\ncontroller = hishel.Controller(\n        # Cache only GET and POST methods\n        cacheable_methods=[\"GET\", \"POST\"],\n\n        # Cache only 200 status codes\n        cacheable_status_codes=[200],\n\n        # Use the stale response if there is a connection issue and the new response cannot be obtained.\n        allow_stale=True,\n\n        # First, revalidate the response and then utilize it.\n        # If the response has not changed, do not download the\n        # entire response data from the server; instead,\n        # use the one you have because you know it has not been modified.\n        always_revalidate=True,\n)\n\n# All the storage configs\nstorage = hishel.S3Storage(\n        bucket_name=\"my_bucket_name\", # store my cache files in the `my_bucket_name` bucket\n        ttl=3600, # delete the response if it is in the cache for more than an hour\n)\nclient = hishel.CacheClient(controller=controller, storage=storage)\n\n\n# Ignore the fact that the server does not recommend you cache this request!\nclient.post(\n        \"https://example.com\",\n        extensions={\"force_cache\": True}\n)\n\n\n# Return a regular response if it is in the cache; else, return a 504 status code. DO NOT SEND A REQUEST!\nclient.post(\n        \"https://example.com\",\n        headers=[(\"Cache-Control\", \"only-if-cached\")]\n)\n\n\n# Ignore cached responses and do not store incoming responses!\nresponse = client.post(\n        \"https://example.com\",\n        extensions={\"cache_disabled\": True}\n)\n</code></pre>"},{"location":"#support-the-project","title":"Support the project","text":"<p>You can support the project by simply leaving a GitHub star \u2b50 or by contributing. Help us grow and continue developing good software for you \u2764\ufe0f</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for being interested in contributing to <code>Hishel</code>. We appreciate your efforts. You can contribute by reviewing the pull requests, opening an issue, or adding a new feature.</p> <p>Here I will describe the development process and the tricks that we use during the development.</p>"},{"location":"contributing/#setting-up","title":"Setting up","text":"<p>First, you should fork the Hishel so you can create your own branch and work on it.</p> <p>Then you should <code>git clone</code> your fork and create a new branch for your pull request.</p> <pre><code>git clone https://github.com/username/hishel\ncd hishel\ngit switch -c my-feature-name\n</code></pre>"},{"location":"contributing/#scripts","title":"Scripts","text":"<p><code>Hishel</code> provides a script directory to simplify the development process. Here is what each command does.</p> <ul> <li>scripts/install Set up the virtual environment and install all the necessary dependencies</li> <li>scripts/lint Runs linter, formatter, and unasync to enforce code style</li> <li>scripts/check Runs all the necessary checks, including linter, formatter, static type analyzer, and unasync checks</li> <li>scripts/test Runs <code>scripts/check</code> + <code>pytest</code> over the coverage.</li> </ul> <p>Example:</p> <pre><code>&gt;&gt;&gt; ./scripts/install\n&gt;&gt;&gt; source ./venv/bin/activate\n&gt;&gt;&gt; ./scripts/test\n+ ./scripts/check\n+ ruff format tests hishel --diff\n26 files left unchanged\n+ ruff tests hishel\n+ mypy tests hishel\nSuccess: no issues found in 38 source files\n+ python unasync.py --check\nhishel/_async/_client.py -&gt; hishel/_sync/_client.py\nhishel/_async/_pool.py -&gt; hishel/_sync/_pool.py\nhishel/_async/_transports.py -&gt; hishel/_sync/_transports.py\nhishel/_async/_mock.py -&gt; hishel/_sync/_mock.py\nhishel/_async/_storages.py -&gt; hishel/_sync/_storages.py\nhishel/_async/__init__.py -&gt; hishel/_sync/__init__.py\ntests/_async/test_storages.py -&gt; tests/_sync/test_storages.py\ntests/_async/test_transport.py -&gt; tests/_sync/test_transport.py\ntests/_async/__init__.py -&gt; tests/_sync/__init__.py\ntests/_async/test_client.py -&gt; tests/_sync/test_client.py\ntests/_async/test_pool.py -&gt; tests/_sync/test_pool.py\n+ coverage run -m pytest tests\n============================ test session starts =============================\nplatform linux -- Python 3.10.12, pytest-7.4.3, pluggy-1.3.0\nrootdir: /home/test/programs/gitprojects/hishel\nconfigfile: pyproject.toml\nplugins: anyio-4.1.0, asyncio-0.21.1\nasyncio: mode=stric`t\ncollected 158 items                                                          \n\ntests/test_controller.py ..........................................    [ 26%]\ntests/test_headers.py .....................                            [ 39%]\ntests/test_lfu_cache.py ......                                         [ 43%]\ntests/test_serializers.py .....                                        [ 46%]\ntests/test_utils.py ........                                           [ 51%]\ntests/_async/test_client.py ..                                         [ 53%]\ntests/_async/test_pool.py ..................                           [ 64%]\ntests/_async/test_storages.py ...........                              [ 71%]\ntests/_async/test_transport.py ..................                      [ 82%]\ntests/_sync/test_client.py .                                           [ 83%]\ntests/_sync/test_pool.py .........                                     [ 89%]\ntests/_sync/test_storages.py ........                                  [ 94%]\ntests/_sync/test_transport.py .........                                [100%]\n\n============================ 158 passed in 2.97s ============================= \n</code></pre> <p>Note</p> <p>Some tests may fail if you don't have all the necessary services. For example, you don't have Redis to pass the integration tests, so there is a Docker compose file in the root directory to start those services.</p>"},{"location":"contributing/#async-and-sync","title":"Async and Sync","text":"<p>Like <code>HTTP Core</code>, <code>Hishel</code> also uses the unasync strategy to support both async and sync code.</p> <p>The idea behind <code>unasync</code> is that you are writing only async code and also using some logic that converts your async code to sync code rather than writing almost the same code twice.</p> <p>In <code>Hishel</code>, there is a <code>unasync.py</code> script that converts an async directory to a sync one.</p> <p>Warning</p> <p>You should not write any code in the <code>hishel/_sync</code> directory. It is always generated by the <code>unasync.py</code> scripts, and after running CI, all your changes to that directory would be lost.</p> <p>Unasync scripts would automatically be called from <code>scripts/lint</code>, so you should just write an async code and then call <code>scripts/lint</code>.</p>"},{"location":"userguide/","title":"User Guide","text":"<p><code>Hishel</code> provides powerful tools for improving your transports.</p> <p>It analyzes your responses and saves them so they can be reused in the future.</p> <p>It is very simple to integrate with your existing application; simply change the <code>Client</code> or <code>Transport</code> class that you are using.</p>"},{"location":"userguide/#clients-and-transports","title":"Clients and Transports","text":"<p>There are three ways to make the httpx library cacheable when working with it.</p> <ul> <li>Use the class provided by <code>Hishel</code> to completely replace <code>HTTPX's Client</code>.</li> <li>Simply use your existing httpx client along with <code>Hishel's transports</code>.</li> <li>Mock the httpx classes using the <code>hishel.install_cache</code> function.</li> </ul> <p>It is always advised to use the second option because it is more reliable and adaptable.</p> <p>Warning</p> <p>Use the <code>hishel.install_cache</code> function only for experiments, and do not rely on the functionality provided by <code>hishel.install_cache</code>.</p>"},{"location":"userguide/#using-the-clients","title":"Using the Clients","text":"<p><code>Hishel</code> offers two classes for the first choice.</p> <ul> <li><code>hishel.AsyncCacheClient</code> for <code>httpx.AsyncClient</code></li> <li><code>hishel.CacheClient</code> for <code>httpx.Client</code></li> </ul> <p>This implies that you can enable HTTP caching in your existing application by simply switching to the proper Client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; \n&gt;&gt;&gt; with hishel.CacheClient() as client:\n&gt;&gt;&gt;     client.get(\"https://example.com/cachable-endpoint\")\n&gt;&gt;&gt;     response = client.get(\"https://example.com/cachable-endpoint\") # from the cache!\n</code></pre> <p>Asynchronous Example:</p> <pre><code>&gt;&gt;&gt; with hishel.AsyncCacheClient() as client:\n&gt;&gt;&gt;     await client.get(\"https://example.com/cachable-endpoint\")\n&gt;&gt;&gt;     response = await client.get(\"https://example.com/cachable-endpoint\") # from the cache!\n</code></pre> <p>Warning</p> <p>The client classes that <code>Hishel</code> offers hide the constructor signature in order to support all possible httpx versions. This means that all httpx client fields are fully valid for those clients, but because they are hidden, your IDE cannot suggest which arguments you can pass. In other words, these classes merely use *args and **kwargs and add a few arguments for cache configuration.</p> <p>This example also functions as long as the cache clients are fully compatible with the standard clients.</p> <p>Example:</p> <pre><code>client = hishel.CacheClient(\n    proxies={\n        \"all://\": \"https://myproxy.com\"\n    },\n    auth=(\"login\", \"password\"),\n    follow_redirects=True,\n    http1=False,\n    http2=True\n)\n\nclient.get(\"https://example.com\")\n</code></pre>"},{"location":"userguide/#specifying-the-client-storage","title":"Specifying the Client storage","text":"<p>Sometimes you may need to select storage rather than filesystem, and this is how you do it.</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage()\nwith hishel.CacheClient(storage=storage) as client:\n    client.get(\"https://example.com\")\n</code></pre> <p>The responses are now saved in the redis database.</p> <p>By default it will use...</p> <ul> <li>host: localhost</li> <li>port: 6379.</li> </ul> <p>Of course, you can explicitly set each configuration.</p> <p>Example:</p> <pre><code>import hishel\nimport redis\n\nstorage = hishel.RedisStorage(\n    client=redis.Redis(\n        host=\"192.168.0.85\",\n        port=8081,\n    )\n)\n\nwith hishel.CacheClient(storage=storage) as client:\n    client.get(\"https://example.com\")\n</code></pre> <p>Note</p> <p>Make sure <code>Hishel</code> has the redis extension installed if you want to use the Redis database. <pre><code>$ pip install hishel[redis]\n</code></pre></p>"},{"location":"userguide/#using-the-transports","title":"Using the Transports","text":"<p>It is always preferable to use transports that <code>Hishel</code> offers for more dependable and predictable behavior.</p> <p>We advise you to read the transports documentation if you have never used <code>HTTPX's transports</code> before continuing.</p> <p>We can divide the httpx library into two parts: the transports and the rest of the httpx library. Transports are the objects that are actually making the request.</p> <p>For synchronous and asynchronous requests, <code>Hishel</code> offers two different transports.</p> <ul> <li>CacheTransport</li> <li>AsyncCacheTransport</li> </ul> <p><code>Hishel</code> always needs a transport to work on top of it, as long as he respects the custom or third-party transports that are offered.</p> <p>Example: <pre><code>import hishel\nimport httpx\n\nwith httpx.HTTPTransport() as transport:\n    with hishel.CacheTransport(transport=transport) as cache_transport:\n        request = httpx.Request(\"GET\", \"https://example.com/cachable-endpoint\")\n        cache_transport.handle_request(request)\n        response = cache_transport.handle_request(request) # from the cache!\n</code></pre></p>"},{"location":"userguide/#using-the-transports-with-the-clients","title":"Using the Transports with the Clients","text":"<p>If you have a transport, you can provide it to clients who will use it for underlying requests.</p> <pre><code>import hishel\nimport httpx\n\ncache_transport = hishel.CacheTransport(transport=httpx.HTTPTransport())\nwith httpx.Client(transport=cache_transport) as client:\n    client.get(\"https://example.com/cachable-endpoint\")\n    response = client.get(\"https://example.com/cachable-endpoint\")  # from the cache\n</code></pre>"},{"location":"userguide/#specifying-the-transport-storage","title":"Specifying the Transport storage","text":"<p>In the same way that we can choose the storage for our clients, we can do the same for our transport.</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage()\nwith httpx.HTTPTransport() as transport:\n    with hishel.CacheTransport(transport=transport, storage=storage) as cache_transport:\n        request = httpx.Request(\"GET\", \"https://example.com/cachable-endpoint\")\n        cache_transport.handle_request(request)\n</code></pre>"},{"location":"userguide/#combining-with-the-existing-transports","title":"Combining with the existing Transports","text":"<p>Assume you already have a custom transport adapted to your business logic that you use for all requests; this is how you can add the caching layer on top of it.</p> <pre><code>import hishel\nimport httpx\nfrom my_custom_transports import MyLovelyTransport\n\ncache_transport = hishel.CacheTransport(transport=MyLovelyTransport())\nwith httpx.Client(transport=cache_transport) as client:\n    client.get(\"https://example.com/cachable-endpoint\")\n    response = client.get(\"https://example.com/cachable-endpoint\")  # from the cache\n</code></pre>"},{"location":"userguide/#using-the-connection-pool","title":"Using the Connection Pool","text":"<p><code>Hishel</code> also provides caching support for the httpcore library, which handles all of the low-level network staff for httpx.</p> <p>You may skip this section if you do not use HTTP Core.</p> <p>Example:</p> <pre><code>import hishel\nimport httpcore\n\nwith httpcore.ConnectionPool() as pool:\n    with hishel.CacheConnectionPool(pool=pool) as cache_pool:\n        cache_pool.get(\"https://example.com/cachable-endpoint\")\n        response = cache_pool.get(\"https://example.com/cachable-endpoint\") # from the cache\n</code></pre>"},{"location":"userguide/#specifying-the-connection-pool-storage","title":"Specifying the Connection Pool storage","text":"<p>In the same way that we can choose the storage for our clients and transports, we can do the same for our connection pools.</p> <pre><code>import hishel\nimport httpcore\n\nstorage = hishel.RedisStorage()\nwith httpcore.ConnectionPool() as pool:\n    with hishel.CacheConnectionPool(pool=pool, storage=storage) as cache_pool:\n        cache_pool.get(\"https://example.com/cachable-endpoint\")\n        response = cache_pool.get(\"https://example.com/cachable-endpoint\") # from the cache\n</code></pre>"},{"location":"userguide/#temporarily-disabling-the-cache","title":"Temporarily Disabling the Cache","text":"<p><code>Hishel</code> allows you to temporarily disable the cache for specific requests using the <code>cache_disabled</code> extension. Per RFC9111, the cache can effectively be disabled using the <code>Cache-Control</code> headers <code>no-store</code> (which requests that the response not be added to the cache), and <code>max-age=0</code> (which demands that any response in the cache must have 0 age - i.e. be a new request). <code>Hishel</code> respects this behavior, which can be used in two ways. First, you can specify the headers directly:</p> <pre><code>import hishel\nimport httpx\n\n# With the clients\nclient = hishel.CacheClient()\nclient.get(\n    \"https://example.com/cacheable-endpoint\",\n    headers=[(\"Cache-Control\", \"no-store\"), (\"Cache-Control\", \"max-age=0\")]\n    ) # Ignores the cache\n\n# With the transport\ncache_transport = hishel.CacheTransport(transport=httpx.HTTPTransport())\nclient = httpx.Client(transport=cache_transport)\nclient.get(\n    \"https://example.com/cacheable-endpoint\",\n    headers=[(\"Cache-Control\", \"no-store\"), (\"Cache-Control\", \"max-age=0\")]\n    ) # Ignores the cache\n</code></pre> <p>Since this can be cumbersome, <code>Hishel</code> also provides some \"syntactic sugar\" to accomplish the same result using <code>HTTPX</code> extensions:</p> <p><pre><code>import hishel\nimport httpx\n\n# With the clients\nclient = hishel.CacheClient()\nclient.get(\"https://example.com/cacheable-endpoint\", extensions={\"cache_disabled\": True}) # Ignores the cache\n\n# With the transport\ncache_transport = hishel.CacheTransport(transport=httpx.HTTPTransport())\nclient = httpx.Client(transport=cache_transport)\nclient.get(\"https://example.com/cacheable-endpoint\", extensions={\"cache_disabled\": True}) # Ignores the cache\n</code></pre> Both of these are entirely equivalent to specifying the headers directly.</p>"},{"location":"advanced/controllers/","title":"Controllers","text":"<p><code>Hishel</code> provides the <code>Controllers</code>, which allow you to fully customize how the cache works at the specification level.</p> <p>You can choose which parts of RFC 9111 to ignore. For example, this is useful when you want to ensure that your client does not use stale responses even if they are acceptable from the server.</p>"},{"location":"advanced/controllers/#force-caching","title":"Force caching","text":"<p>If you only need to cache responses without validating the headers and following RFC9111 rules, simply set the <code>force_cache</code> property to true.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(force_cache=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>force_cache extension will always overwrite the controller's force_cache property.</p>"},{"location":"advanced/controllers/#cachable-http-methods","title":"Cachable HTTP methods","text":"<p>You can specify which HTTP methods <code>Hishel</code> should cache.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(cacheable_methods=[\"GET\", \"POST\"])\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p><code>Hishel</code> will only cache <code>GET</code> methods if the cachable methods are not explicitly specified.</p>"},{"location":"advanced/controllers/#cachable-status-codes","title":"Cachable status codes","text":"<p>If you only want to cache specific status codes, do so.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(cacheable_status_codes=[301, 308])\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>If the cachable status codes are not explicitly specified, <code>Hishel</code> will only cache status codes 200, 301, and 308.</p>"},{"location":"advanced/controllers/#allowing-heuristics","title":"Allowing heuristics","text":"<p>You can enable heuristics calculations, which are disabled by default.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(allow_heuristics=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p><code>Hishel</code> is very conservative about what status codes are permitted to be heuristically cacheable. When <code>allow_heuristics</code> is enabled, <code>Hishel</code> will only cache responses having status codes 200, 301, and 308. In contrast, RFC 9111 specifies that many more responses can be heuristically cacheable, specifically 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501.</p> <p>If you would prefer heuristic caching to the fullest extent permitted by RFC 9111, then pass <code>HEURISTICALLY_CACHEABLE_STATUS_CODES</code> to <code>cacheable_status_codes</code>:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(\n    allow_heuristics=True,\n    cacheable_status_codes=hishel.HEURISTICALLY_CACHEABLE_STATUS_CODES\n    )\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Tip</p> <p>If you're not familiar with <code>Heuristics Caching</code>, you can read about it in the specification.</p>"},{"location":"advanced/controllers/#preventing-caching-of-private-responses","title":"Preventing caching of private responses","text":"<p>If you want <code>Hishel</code> to act as a shared cache, you need to prevent it from caching responses with the <code>private</code> directive.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(cache_private=False)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>Servers may prohibit only some headers from being stored in a shared cache by sending a header such as <code>Cache-Control: private=set-cookie</code>. However, <code>Hishel</code> with <code>cache_private=False</code> will still not cache the response, at all.</p>"},{"location":"advanced/controllers/#allowing-stale-responses","title":"Allowing stale responses","text":"<p>Some servers allow the use of stale responses if they cannot be re-validated or the client is disconnected from the server. Clients MAY use stale responses in such cases, but this behavior is disabled by default in <code>Hishel</code>.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(allow_stale=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Tip</p> <p><code>Hishel</code> will attempt to use stale response only if the client is unable to connect to the server to make a request. You can enable stale responses to receive responses even if your internet connection is lost.</p>"},{"location":"advanced/controllers/#specifying-revalidation-behavior","title":"Specifying revalidation behavior","text":"<p>Responses are revalidated by default when they become stale; however, you can always revalidate the responses if you wish.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(always_revalidate=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>Because we already have the response body in our cache, revalidation is very quick.</p>"},{"location":"advanced/controllers/#custom-cache-keys","title":"Custom cache keys","text":"<p>By default, <code>Hishel</code> generates cache keys as a hash of the request method and url. However, you can customize cache key creation by writing a function with the signature <code>Callable[[httpcore.Request], str]</code> and passing it to the controller.</p> <p>Example:</p> <pre><code>import hishel\nimport httpcore\nfrom hishel._utils import generate_key\n\ndef custom_key_generator(request: httpcore.Request, body: bytes):\n    key = generate_key(request, body)\n    method = request.method.decode()\n    host = request.url.host.decode()\n    return f\"{method}|{host}|{key}\"\n\ncontroller = hishel.Controller(key_generator=custom_key_generator)\nclient = hishel.CacheClient(controller=controller)\n\nclient.get(\"https://hishel.com\")\n</code></pre> <p>Instead of just the <code>hashed_value</code>, the key now has the format <code>method|host|hashed_value</code>.</p> <p>Note</p> <p>Cache keys are used to store responses in storages, such as filesystem storage, which will use the cache key to create a file with that value. You can write your own cache key implementation to have more meaningful file names and simplify cache monitoring.</p> BeforeAfter <pre><code>\ud83d\udcc1 root\n\u2514\u2500\u2574\ud83d\udcc1 .cache\n   \u2514\u2500\u2574\ud83d\udcc1 hishel\n      \u2514\u2500\u2574\ud83d\udcc4 41ebb4dd16761e94e2ee36b71e0d916e\n</code></pre> <pre><code>\ud83d\udcc1 root\n\u2514\u2500\u2574\ud83d\udcc1 .cache\n   \u2514\u2500\u2574\ud83d\udcc1 hishel\n      \u2514\u2500\u2574\ud83d\udcc4 GET|hishel.com|41ebb4dd16761e94e2ee36b71e0d916e\n</code></pre>"},{"location":"advanced/extensions/","title":"Extensions","text":"<p><code>HTTPX</code> provides an extension mechanism to allow additional information  to be added to requests and to be returned in responses. <code>hishel</code> makes use of these extensions to expose some additional cache-related options and metadata. These extensions are available from either the <code>hishel.CacheClient</code> /  <code>hishel.AsyncCacheClient</code> or a <code>httpx.Client</code> / <code>httpx.AsyncCacheClient</code> using a <code>hishel</code> transport.</p>"},{"location":"advanced/extensions/#request-extensions","title":"Request extensions","text":""},{"location":"advanced/extensions/#force_cache","title":"force_cache","text":"<p>If this extension is set to true, <code>Hishel</code> will cache the response even if response headers would otherwise prevent caching the response.</p> <p>For example, if the response has a <code>Cache-Control</code> header that contains a <code>no-store</code> directive, it will not cache the response unless the <code>force_cache</code> extension is set to true.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/uncachable-endpoint\", extensions={\"force_cache\": True})\n</code></pre> <p>Note</p> <p>You can configure this extension globally for the controller, rather than setting force_cache to True for each request.</p>"},{"location":"advanced/extensions/#cache_disabled","title":"cache_disabled","text":"<p>This extension temporarily disables the cache by passing appropriate RFC9111 headers to ignore cached responses and to not store incoming responses. For example:</p> <p><pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/cacheable-endpoint\", extensions={\"cache_disabled\": True})\n</code></pre> This feature is more fully documented in the User Guide</p>"},{"location":"advanced/extensions/#response-extensions","title":"Response extensions","text":""},{"location":"advanced/extensions/#from_cache","title":"from_cache","text":"<p>Every response from  will have a <code>from_cache</code> extension value that will be <code>True</code> when the response was retrieved from the cache, and <code>False</code> when the response was received over the network.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com\")\n&gt;&gt;&gt; response.extensions[\"from_cache\"]\nFalse\n&gt;&gt;&gt; response = client.get(\"https://www.example.com\")\n&gt;&gt;&gt; response.extensions[\"from_cache\"]\nTrue\n</code></pre>"},{"location":"advanced/extensions/#revalidated","title":"revalidated","text":"<p>Every response will have a <code>revalidated</code> extension that indicates whether the response has been revalidated or not.</p> <p>Note</p> <p>Note that a response could have <code>revalidated</code> set to <code>True</code> even when <code>from_cache</code> is set to <code>False</code>. This occurs when the cached entry has been updated and a new entry is downloaded during revalidation.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/endpoint_that_is_fresh\")\n&gt;&gt;&gt; response.extensions[\"revalidated\"]\nFalse\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/endpoint_that_is_stale\")\n&gt;&gt;&gt; response.extensions[\"revalidated\"]\nTrue\n</code></pre>"},{"location":"advanced/extensions/#cache_metadata","title":"cache_metadata","text":"<p>If <code>from_cache</code> is <code>True</code>, the response will also include a <code>cache_metadata</code> extension with additional information about  the response retrieved from the cache. If <code>from_cache</code> is <code>False</code>, then <code>cache_metadata</code> will not be present in the response extensions.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/cacheable-endpoint\")\n&gt;&gt;&gt; response.extensions\n{\n    ... # other extensions\n    \"from_cache\": False\n}\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/cacheable-endpoint\")\n&gt;&gt;&gt; response.extensions\n{\n    ... # other extensions\n    \"from_cache\": True\n    \"cache_metadata\" : {\n        \"cache_key': '1a4c648c9a61adf939eef934a73e0cbe',\n        'created_at': datetime.datetime(2020, 1, 1, 0, 0, 0),\n        'number_of_uses': 1,\n    }\n}\n</code></pre>"},{"location":"advanced/http_headers/","title":"HTTP Headers","text":"<p>You can use the request <code>Cache-Control</code> directives defined in RFC 9111 to make the cache behavior more explicit in some situations.</p>"},{"location":"advanced/http_headers/#only-if-cached","title":"only-if-cached","text":"<p>If this directive is present in the request headers, the cache should either use the cached response or return the 504 status code.</p> <p>Note</p> <p>It is guaranteed that the client will not make any requests; instead, it will try to find a response from the cache that can be used for this request.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; \n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://example.com\", headers=[(\"Cache-Control\", \"only-if-cached\")])\n&gt;&gt;&gt; response\n&lt;Response [504 Gateway Timeout]&gt;\n</code></pre> <p>or</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; \n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; client.get(\"https://google.com\")  # will cache\n&gt;&gt;&gt; response = client.get(\"https://google.com\", headers=[(\"Cache-Control\", \"only-if-cached\")])\n&gt;&gt;&gt; response\n&lt;Response [301 Moved Permanently]&gt;\n</code></pre>"},{"location":"advanced/http_headers/#max-age","title":"max-age","text":"<p>If this directive is present in the request headers, the cache should ignore responses that are older than the specified number.</p> <p>Example:</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"max-age=3600\")])\n</code></pre>"},{"location":"advanced/http_headers/#max-stale","title":"max-stale","text":"<p>If this directive is present in the request headers, the cache should ignore responses that have exceeded their freshness lifetime by more than the specified number of seconds.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"max-stale=3600\")])\n</code></pre>"},{"location":"advanced/http_headers/#min-fresh","title":"min-fresh","text":"<p>If this directive is present in the request headers, the cache should ignore responses that will not be fresh for at least the number of seconds specified.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"min-fresh=3600\")])\n</code></pre>"},{"location":"advanced/http_headers/#no-cache","title":"no-cache","text":"<p>If this directive is present in the request headers, the cache should not use the response to this request unless it has been validated.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"no-cache\")])\n</code></pre>"},{"location":"advanced/http_headers/#no-store","title":"no-store","text":"<p>If this directive is present in the request headers, the cache should not save the response to this request.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"no-store\")])\n</code></pre>"},{"location":"advanced/logging/","title":"Logging","text":"<p>Logging is an important part of every application that helps developers better understand how the program operates. Hishel supports a variety of logs that can show you how the library impacts your program.</p> <p>Hishel will support several loggers for different parts of the program. Currently, we support only one logger called <code>hishel.controller</code>, which logs any event related to the cache. For example, it logs when a response is considered stale, when revalidation occurs, when a response is used from the cache, and more.</p>"},{"location":"advanced/logging/#controller-logs","title":"Controller logs","text":"<p>The controller is a part of the Hishel library that interprets the caching specification. It determines whether a response can be cached or retrieved from the cache.</p> <p>You can configure the controller logger for debugging purposes or to better understand how caching works. It can also be crucial when you're just starting out and want to understand why a particular response isn't being cached.</p> <p>For example, let's enable logging and see what gets logged when making an HTTP request to the Hishel documentation.</p> <pre><code>import logging\nimport hishel\n\nlogging.basicConfig(\n    level=logging.WARNING,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogging.getLogger(\"hishel.controller\").setLevel(logging.DEBUG)\n\nclient = hishel.CacheClient()\n\nresponse = client.get(\n    \"https://hishel.com\",\n)\n</code></pre> <p>Here is what Hishel will log for this program:</p> <pre><code>2024-09-30 16:32:34,799 - hishel.controller - DEBUG - Considering the resource located at https://hishel.com/ as cachable since it meets the criteria for being stored in the cache.\n</code></pre> <p>If you run this program a second time, you will receive the response from the cache because hishel.com sends all the necessary caching headers. So, for the second run, you will see a log entry about the successfully reused response.</p> <pre><code>2024-09-30 16:35:14,102 - hishel.controller - DEBUG - Considering the resource located at https://hishel.com/ as valid for cache use since it is fresh.\n</code></pre> <p>If we wait some time, the cached response will, of course, become stale. After some time, you can run this program again and see that the response needs to be revalidated from the server to obtain the most recent data. The logs could look like this:</p> <pre><code>2024-09-30 16:39:42,502 - hishel.controller - DEBUG - Considering the resource located at https://hishel.com/ as needing revalidation since it is not fresh.\n2024-09-30 16:39:42,502 - hishel.controller - DEBUG - Adding the 'If-Modified-Since' header with the value of 'Fri, 27 Sep 2024 07:42:28 GMT' to the request for the resource located at https://hishel.com/.\n</code></pre> <p>The controller will indicate not only that the response was cached but also why it was considered cacheable.</p> <p>Examples:</p> <ul> <li> <p>For permanent redirects <pre><code>2024-09-30 16:43:04,672 - hishel.controller - DEBUG - Considering the resource located at https://www.github.com/ as cachable since its status code is a permanent redirect.\n</code></pre></p> </li> <li> <p>When force_cache is enabled <pre><code>2024-09-30 16:45:10,468 - hishel.controller - DEBUG - Considering the resource located at https://www.google.com/ as valid for cache use since the request is forced to use the cache.\n</code></pre></p> </li> </ul> <p>Or when it's considered as not cachable</p> <pre><code>2024-09-30 17:02:24,961 - hishel.controller - DEBUG - Considering the resource located at https://www.python.org/ as not cachable since it does not contain any of the required cache directives.\n</code></pre> <p>Here you can find a full list of the controller logs. Note that this is the list of initial logs; any logs added later will not be updated in this list.</p>"},{"location":"advanced/serializers/","title":"Serializers","text":"<p>Serializers are a component of storages that simply serialize and de-serialize responses. Hishel will use JSONSerializer by default, but you can explicitly specify a serializer or even write your own.</p> <p>Example of the serialized responses:</p> JSONYaml <pre><code>{\n    \"response\": {\n        \"status\": 301,\n        \"headers\": [\n            [\n                \"Content-Length\",\n                \"0\"\n            ],\n            [\n                \"Location\",\n                \"https://github.com/\"\n            ]\n        ],\n        \"content\": \"\",\n        \"extensions\": {\n            \"http_version\": \"HTTP/1.1\",\n            \"reason_phrase\": \"Moved Permanently\"\n        }\n    },\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"https://www.github.com/\",\n        \"headers\": [\n            [\n                \"Host\",\n                \"www.github.com\"\n            ],\n            [\n                \"Accept\",\n                \"*/*\"\n            ],\n            [\n                \"Accept-Encoding\",\n                \"gzip, deflate\"\n            ],\n            [\n                \"Connection\",\n                \"keep-alive\"\n            ],\n            [\n                \"User-Agent\",\n                \"python-httpx/0.24.1\"\n            ]\n        ],\n        \"extensions\": {\n            \"timeout\": {\n                \"connect\": 5.0,\n                \"read\": 5.0,\n                \"write\": 5.0,\n                \"pool\": 5.0\n            }\n        }\n    },\n    \"metadata\": {\n        \"cache_key\": \"71b46af84732856e5c16d503b655fcd0\",\n        \"number_of_uses\": 0,\n        \"created_at\": \"Mon, 21 Aug 2023 05:22:20 GMT\"\n    }\n}\n</code></pre> <pre><code>response:\n  status: 301\n  headers:\n  - - Content-Length\n    - '0'\n  - - Location\n    - https://github.com/\n  content: ''\n  extensions:\n    http_version: HTTP/1.1\n    reason_phrase: Moved Permanently\nrequest:\n  method: GET\n  url: https://www.github.com/\n  headers:\n  - - Host\n    - www.github.com\n  - - Accept\n    - '*/*'\n  - - Accept-Encoding\n    - gzip, deflate\n  - - Connection\n    - keep-alive\n  - - User-Agent\n    - python-httpx/0.24.1\n  extensions:\n    timeout:\n      connect: 5.0\n      read: 5.0\n      write: 5.0\n      pool: 5.0\nmetadata:\n  cache_key: 71b46af84732856e5c16d503b655fcd0\n  number_of_uses: 0\n  created_at: Mon, 21 Aug 2023 05:22:20 GMT\n</code></pre>"},{"location":"advanced/serializers/#jsonserializer","title":"JSONSerializer","text":"<p>Example: <pre><code>import hishel\n\nserializer = hishel.JSONSerializer()\nstorage = hishel.FileStorage(serializer=serializer)\n</code></pre></p> <p>Because serializers are supported by all of the built-in <code>hishel</code> storages, you can pass serializers to any of them.</p> <p>Example: <pre><code>import hishel\n\nserializer = hishel.JSONSerializer()\nstorage = hishel.RedisStorage(serializer=serializer)\n</code></pre></p>"},{"location":"advanced/serializers/#yamlserizlier","title":"YAMLSerizlier","text":"<p>Example: <pre><code>import hishel\n\nserializer = hishel.YAMLSerializer()\nstorage = hishel.FileStorage(serializer=serializer)\n</code></pre></p> <p>Note</p> <p>Make sure <code>Hishel</code> has the yaml extension installed if you want to use the <code>YAMLSerializer</code>. <pre><code>$ pip install hishel[yaml]\n</code></pre></p>"},{"location":"advanced/serializers/#pickleserializer","title":"PickleSerializer","text":"<p>Example: <pre><code>import hishel\n\nserializer = hishel.PickleSerializer()\nstorage = hishel.FileStorage(serializer=serializer)\n</code></pre></p>"},{"location":"advanced/storages/","title":"Storages","text":"<p>When using <code>Hishel</code>, you have complete control over the configuration of how the responses should be stored. You can select the serializer and storage on your own.</p> <p>This section contains examples of how to use the storages.</p>"},{"location":"advanced/storages/#filesystem-storage","title":"Filesystem storage","text":"<p>To explicitly specify the storage, we should create it first and pass it to the HTTP caching class.</p> <p>Example: <pre><code>import hishel\n\nstorage = hishel.FileStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre></p> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.FileStorage()\ntransport = hishel.CacheTransport(transport=httpx.HTTPTransport(), storage=storage)\n</code></pre> <p>Here's how the filesystem storage looks:</p> <pre><code>\ud83d\udcc1 root\n\u2514\u2500\u2574\ud83d\udcc1 .cache\n   \u2514\u2500\u2574\ud83d\udcc1 hishel\n      \u251c\u2500\u2574\ud83d\udcc4 GET|github.com|a9022e44881123781045f6fadf37a8b1\n      \u251c\u2500\u2574\ud83d\udcc4 GET|www.google.com|8bfc7fffcfd5f2b8e3485d0cc7450c98\n      \u251c\u2500\u2574\ud83d\udcc4 GET|www.python-httpx.org|5f004f4f08bd774c4bc4b270a0ca542e\n      \u2514\u2500\u2574\ud83d\udcc4 GET|hishel.com|41ebb4dd16761e94e2ee36b71e0d916e\n</code></pre> <p>Note</p> <p>Note that by default, file names are just the hashed value, without the http method or hostname; to have meaningful names, see custom cache keys.</p>"},{"location":"advanced/storages/#storage-directory","title":"Storage directory","text":"<p>If the responses are saved in the filesystem, there should be a directory that contains our responses.</p> <p>By default it's <code>.cache/hishel</code>.</p> <p>If you want to change the directory, do so as follows.</p> <pre><code>import hishel\n\nstorage = hishel.FileStorage(base_path=\"/home/test/my_cache_dir\")\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-filestorage","title":"Responses ttl in FileStorage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.FileStorage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#check-ttl-every","title":"Check ttl every","text":"<p>In order to avoid excessive memory utilization, <code>Hishel</code> must periodically clean the old responses, or responses that are not being used and should be deleted from the cache. It clears the cache by default every minute, but you may change the interval directly with the <code>check_ttl_every</code> argument.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.FileStorage(check_ttl_every=600) # check every 600s (10m) \n</code></pre>"},{"location":"advanced/storages/#in-memory-storage","title":"In-memory storage","text":"<p><code>Hishel</code> has an in-memory cache that can be used when you don't need the cache to be persistent.</p> <p>You should understand that in memory cache means that all cached responses are stored in RAM, so you should be cautious and possibly configure the cache's maximum size to avoid wasting RAM.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.InMemoryStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.InMemoryStorage()\nclient = hishel.CacheTransport(transport=httpx.HTTPTransport(), storage=storage)\n</code></pre>"},{"location":"advanced/storages/#set-the-maximum-capacity","title":"Set the maximum capacity","text":"<p>You can also specify the maximum number of requests that the storage can cache. </p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.InMemoryStorage(capacity=64)\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Note</p> <p>When the number of responses exceeds the cache's capacity, Hishel employs the LFU algorithm to remove some of the responses. </p>"},{"location":"advanced/storages/#redis-storage","title":"Redis storage","text":"<p><code>Hishel</code> includes built-in redis support, allowing you to store your responses in redis.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.RedisStorage()\nclient = hishel.CacheTransport(transport=httpx.HTTPTransport(), storage=storage)\n</code></pre>"},{"location":"advanced/storages/#custom-redis-client","title":"Custom redis client","text":"<p>If you need to connect somewhere other than localhost, this is how you can do it.</p> <pre><code>import hishel\nimport redis\n\nstorage = hishel.RedisStorage(\n    client=redis.Redis(\n        host=\"192.168.0.85\",\n        port=8081,\n    )\n)\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-redisstorage","title":"Responses ttl in RedisStorage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#sqlite-storage","title":"SQLite storage","text":"<p><code>Hishel</code> includes built-in sqlite support, allowing you to store your responses in sqlite database.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.SQLiteStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.SQLiteStorage()\nclient = hishel.CacheTransport(transport=httpx.HTTPTransport())\n</code></pre> <p>Note</p> <p>Make sure <code>Hishel</code> has the sqlite extension installed if you want to use the <code>AsyncSQLiteStorage</code>. <pre><code>$ pip install hishel[sqlite]\n</code></pre></p>"},{"location":"advanced/storages/#sqlite-custom-connection","title":"Sqlite custom connection","text":"<p>If you want more control over the underlying sqlite connection, you can explicitly pass it.</p> <pre><code>import hishel\nimport sqlite3\n\nclient = hishel.CacheClient(\n    storage=hishel.SQLiteStorage(connection=sqlite3.connect(\"my_db_path\", timeout=5))\n)\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-sqlitestorage","title":"Responses ttl in SQLiteStorage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.SQLiteStorage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#aws-s3-storage","title":"AWS S3 storage","text":"<p><code>Hishel</code> has built-in AWS S3 support, allowing users to store responses in the cloud.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.S3Storage(bucket_name=\"cached_responses\")\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports <pre><code>import httpx\nimport hishel\n\nstorage = hishel.S3Storage(bucket_name=\"cached_responses\")\ntransport = hishel.CacheTransport(httpx.HTTPTransport(), storage=storage)\n</code></pre></p>"},{"location":"advanced/storages/#custom-aws-s3-client","title":"Custom AWS S3 client","text":"<p>If you want to manually configure the client instance, pass it to Hishel.</p> <pre><code>import hishel\nimport boto3\n\ns3_client = boto3.client('s3')\n\nstorage = hishel.S3Storage(bucket_name=\"cached_responses\", client=s3_client)\nclient = hishel.CacheClient(storage=storage)\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-s3storage","title":"Responses ttl in S3Storage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.S3Storage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#check-ttl-every_1","title":"Check ttl every","text":"<p>In order to avoid excessive memory utilization, <code>Hishel</code> must periodically clean the old responses, or responses that are not being used and should be deleted from the cache. It clears the cache by default every minute, but you may change the interval directly with the <code>check_ttl_every</code> argument.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.S3Storage(check_ttl_every=600) # check every 600s (10m) \n</code></pre>"},{"location":"beta/metadata/","title":"Request and Response Metadata","text":"<p>Metadata allows you to control caching behavior and inspect cache operations. Hishel supports metadata on both requests (to control caching) and responses (to inspect what happened).</p> <p>All metadata fields are prefixed with <code>hishel_</code> to avoid collisions with user data.</p>"},{"location":"beta/metadata/#request-metadata","title":"Request Metadata","text":"<p>Request metadata controls how Hishel caches the request and its response. You can set metadata using:</p> <ul> <li>httpx: <code>extensions</code> parameter (recommended) or <code>X-Hishel-*</code> headers</li> <li>requests: <code>X-Hishel-*</code> headers</li> </ul> <p>httpx supports both methods</p> <p>While httpx supports both <code>extensions</code> and headers, using <code>extensions</code> is recommended as it provides better type safety and doesn't pollute HTTP headers sent to the server.</p>"},{"location":"beta/metadata/#hishel_ttl","title":"hishel_ttl","text":"<p>Type: <code>float | None</code></p> <p>Description: Sets a custom time-to-live (TTL) for the cached response. After the specified number of seconds, the cached response will be considered expired and removed during cleanup.</p> <p>Use Cases:</p> <ul> <li>Override default TTL for specific endpoints</li> <li>Set shorter TTL for frequently changing data</li> <li>Set longer TTL for static resources</li> </ul> <p>Default: Storage's <code>default_ttl</code> setting</p> <p>Example:</p> httpx (extensions)httpx (headers)requests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Cache this response for 1 hour using extensions (recommended)\nresponse = client.get(\n    \"https://api.example.com/data\",\n    extensions={\"hishel_ttl\": 3600}\n)\n</code></pre> <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Cache this response for 1 hour using headers\nresponse = client.get(\n    \"https://api.example.com/data\",\n    headers={\"X-Hishel-Ttl\": \"3600\"}\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Cache this response for 1 hour\nresponse = session.get(\n    \"https://api.example.com/data\",\n    headers={\"X-Hishel-Ttl\": \"3600\"}\n)\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Short TTL for frequently changing stock prices\nstocks = client.get(\n    \"https://api.example.com/stocks\",\n    extensions={\"hishel_ttl\": 60}  # 1 minute\n)\n\n# Long TTL for static configuration\nconfig = client.get(\n    \"https://api.example.com/config\",\n    extensions={\"hishel_ttl\": 86400}  # 24 hours\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Short TTL for frequently changing stock prices\nstocks = session.get(\n    \"https://api.example.com/stocks\",\n    headers={\"X-Hishel-Ttl\": \"60\"}  # 1 minute\n)\n\n# Long TTL for static configuration\nconfig = session.get(\n    \"https://api.example.com/config\",\n    headers={\"X-Hishel-Ttl\": \"86400\"}  # 24 hours\n)\n</code></pre>"},{"location":"beta/metadata/#hishel_refresh_ttl_on_access","title":"hishel_refresh_ttl_on_access","text":"<p>Type: <code>bool | None</code></p> <p>Description: When <code>True</code>, accessing a cached entry resets its TTL, keeping frequently accessed entries fresh. When <code>False</code>, the TTL countdown starts from the original storage time and is not affected by subsequent accesses.</p> <p>Use Cases:</p> <ul> <li>Keep popular content cached longer (sliding expiration)</li> <li>Ensure rarely accessed content expires on schedule (fixed expiration)</li> </ul> <p>Default: Storage's <code>refresh_ttl_on_access</code> setting (typically <code>True</code>)</p> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Enable sliding expiration - each access resets the timer\nresponse = client.get(\n    \"https://api.example.com/user/profile\",\n    extensions={\"hishel_refresh_ttl_on_access\": True}\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Enable sliding expiration - each access resets the timer\nresponse = session.get(\n    \"https://api.example.com/user/profile\",\n    headers={\"X-Hishel-Refresh-Ttl-On-Access\": \"true\"}\n)\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# User session data - keep active sessions cached\n# Each access extends the cache lifetime\nsession_data = client.get(\n    \"https://api.example.com/user/session\",\n    extensions={\n        \"hishel_ttl\": 1800,  # 30 minutes\n        \"hishel_refresh_ttl_on_access\": True  # Reset on each use\n    }\n)\n\n# Analytics report - expire exactly 1 hour after creation\n# Don't extend lifetime even if accessed multiple times\nreport = client.get(\n    \"https://api.example.com/reports/daily\",\n    extensions={\n        \"hishel_ttl\": 3600,  # 1 hour\n        \"hishel_refresh_ttl_on_access\": False  # Fixed expiration\n    }\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# User session data - keep active sessions cached\n# Each access extends the cache lifetime\nsession_data = session.get(\n    \"https://api.example.com/user/session\",\n    headers={\n        \"X-Hishel-Ttl\": \"1800\",  # 30 minutes\n        \"X-Hishel-Refresh-Ttl-On-Access\": \"true\"  # Reset on each use\n    }\n)\n\n# Analytics report - expire exactly 1 hour after creation\n# Don't extend lifetime even if accessed multiple times\nreport = session.get(\n    \"https://api.example.com/reports/daily\",\n    headers={\n        \"X-Hishel-Ttl\": \"3600\",  # 1 hour\n        \"X-Hishel-Refresh-Ttl-On-Access\": \"false\"  # Fixed expiration\n    }\n)\n</code></pre>"},{"location":"beta/metadata/#hishel_spec_ignore","title":"hishel_spec_ignore","text":"<p>Type: <code>bool | None</code></p> <p>Description: When <code>True</code>, Hishel ignores RFC 9111 caching rules and caches the response regardless of <code>Cache-Control</code>, <code>Expires</code>, or other standard headers. The response will be stored even if it would normally be uncacheable.</p> <p>Use Cases:</p> <ul> <li>Force caching of responses with <code>no-store</code> or <code>no-cache</code></li> <li>Cache responses without proper cache headers</li> <li>Override server caching directives for testing</li> </ul> <p>Default: <code>False</code> (follow RFC 9111 specification)</p> <p>Warning</p> <p>Use with caution. Ignoring the specification may cache sensitive data or stale content.</p> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Force caching even if server says not to\nresponse = client.get(\n    \"https://api.example.com/dynamic-content\",\n    extensions={\"hishel_spec_ignore\": True}\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Force caching even if server says not to\nresponse = session.get(\n    \"https://api.example.com/dynamic-content\",\n    headers={\"X-Hishel-Spec-Ignore\": \"true\"}\n)\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Development: Cache API responses that don't have cache headers\n# This reduces API calls during development/testing\nresponse = client.get(\n    \"https://api.example.com/test-endpoint\",\n    extensions={\n        \"hishel_spec_ignore\": True,\n        \"hishel_ttl\": 300  # Cache for 5 minutes\n    }\n)\n\n# Cache a response that has Cache-Control: no-store\n# Useful when you control both client and server\nresponse = client.get(\n    \"https://api.example.com/private-but-cacheable\",\n    extensions={\n        \"hishel_spec_ignore\": True,\n        \"hishel_ttl\": 60\n    }\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Development: Cache API responses that don't have cache headers\n# This reduces API calls during development/testing\nresponse = session.get(\n    \"https://api.example.com/test-endpoint\",\n    headers={\n        \"X-Hishel-Spec-Ignore\": \"true\",\n        \"X-Hishel-Ttl\": \"300\"  # Cache for 5 minutes\n    }\n)\n\n# Cache a response that has Cache-Control: no-store\n# Useful when you control both client and server\nresponse = session.get(\n    \"https://api.example.com/private-but-cacheable\",\n    headers={\n        \"X-Hishel-Spec-Ignore\": \"true\",\n        \"X-Hishel-Ttl\": \"60\"\n    }\n)\n</code></pre>"},{"location":"beta/metadata/#hishel_body_key","title":"hishel_body_key","text":"<p>Type: <code>bool | None</code></p> <p>Description: When <code>True</code>, includes the request body in cache key generation. This allows caching different responses for the same URL but with different request bodies, which is essential for POST requests and GraphQL queries.</p> <p>Use Cases:</p> <ul> <li>Cache POST requests with different payloads</li> <li>Cache GraphQL queries (different queries to same endpoint)</li> <li>Cache search requests with different parameters in body</li> </ul> <p>Default: <code>False</code> (body not included in cache key)</p> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Cache POST request based on body content\nresponse = client.post(\n    \"https://api.example.com/search\",\n    json={\"query\": \"python\"},\n    extensions={\"hishel_body_key\": True}\n)\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Cache POST request based on body content\nresponse = session.post(\n    \"https://api.example.com/search\",\n    json={\"query\": \"python\"},\n    headers={\"X-Hishel-Body-Key\": \"true\"}\n)\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# GraphQL: Cache different queries to the same endpoint\nquery1 = client.post(\n    \"https://api.example.com/graphql\",\n    json={\n        \"query\": \"{ user(id: 1) { name email } }\"\n    },\n    extensions={\n        \"hishel_body_key\": True,\n        \"hishel_ttl\": 300\n    }\n)\n\nquery2 = client.post(\n    \"https://api.example.com/graphql\",\n    json={\n        \"query\": \"{ posts { title author } }\"\n    },\n    extensions={\n        \"hishel_body_key\": True,\n        \"hishel_ttl\": 300\n    }\n)\n# These will be cached separately despite same URL\n\n# Search API: Cache different search queries\nsearch_python = client.post(\n    \"https://api.example.com/search\",\n    json={\"q\": \"python\", \"limit\": 10},\n    extensions={\n        \"hishel_body_key\": True,\n        \"hishel_ttl\": 600\n    }\n)\n\nsearch_javascript = client.post(\n    \"https://api.example.com/search\",\n    json={\"q\": \"javascript\", \"limit\": 10},\n    extensions={\n        \"hishel_body_key\": True,\n        \"hishel_ttl\": 600\n    }\n)\n# Different searches cached separately\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# GraphQL: Cache different queries to the same endpoint\nquery1 = session.post(\n    \"https://api.example.com/graphql\",\n    json={\n        \"query\": \"{ user(id: 1) { name email } }\"\n    },\n    headers={\n        \"X-Hishel-Body-Key\": \"true\",\n        \"X-Hishel-Ttl\": \"300\"\n    }\n)\n\nquery2 = session.post(\n    \"https://api.example.com/graphql\",\n    json={\n        \"query\": \"{ posts { title author } }\"\n    },\n    headers={\n        \"X-Hishel-Body-Key\": \"true\",\n        \"X-Hishel-Ttl\": \"300\"\n    }\n)\n# These will be cached separately despite same URL\n\n# Search API: Cache different search queries\nsearch_python = session.post(\n    \"https://api.example.com/search\",\n    json={\"q\": \"python\", \"limit\": 10},\n    headers={\n        \"X-Hishel-Body-Key\": \"true\",\n        \"X-Hishel-Ttl\": \"600\"\n    }\n)\n\nsearch_javascript = session.post(\n    \"https://api.example.com/search\",\n    json={\"q\": \"javascript\", \"limit\": 10},\n    headers={\n        \"X-Hishel-Body-Key\": \"true\",\n        \"X-Hishel-Ttl\": \"600\"\n    }\n)\n# Different searches cached separately\n</code></pre>"},{"location":"beta/metadata/#response-metadata","title":"Response Metadata","text":"<p>Response metadata provides information about cache operations that occurred. These fields are read-only and set by Hishel.</p>"},{"location":"beta/metadata/#hishel_from_cache","title":"hishel_from_cache","text":"<p>Type: <code>bool | None</code></p> <p>Description: Indicates whether the response was served from cache (<code>True</code>) or fetched from the origin server (<code>False</code>).</p> <p>Use Cases:</p> <ul> <li>Monitor cache hit rates</li> <li>Debug caching behavior</li> <li>Log cache performance</li> <li>Conditional logic based on cache status</li> </ul> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\nresponse = client.get(\"https://api.example.com/data\")\n\n# Check if response came from cache\nif response.extensions.get(\"hishel_from_cache\"):\n    print(\"\u2713 Cache hit\")\nelse:\n    print(\"\u2717 Cache miss - fetched from origin\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\nresponse = session.get(\"https://api.example.com/data\")\n\n# Check if response came from cache\nif response.headers.get(\"X-Hishel-From-Cache\") == \"true\":\n    print(\"\u2713 Cache hit\")\nelse:\n    print(\"\u2717 Cache miss - fetched from origin\")\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\nimport time\n\nclient = SyncCacheClient()\n\n# Monitor cache performance\ncache_hits = 0\ncache_misses = 0\n\nfor i in range(100):\n    response = client.get(\"https://api.example.com/popular-data\")\n\n    if response.extensions.get(\"hishel_from_cache\"):\n        cache_hits += 1\n    else:\n        cache_misses += 1\n\nhit_rate = (cache_hits / 100) * 100\nprint(f\"Cache hit rate: {hit_rate}%\")\n\n# Conditional processing based on cache status\nresponse = client.get(\"https://api.example.com/user/profile\")\n\nif response.extensions.get(\"hishel_from_cache\"):\n    print(\"Using cached profile - may be slightly outdated\")\nelse:\n    print(\"Fresh profile data from server\")\n    # Trigger additional processing for fresh data\n    process_fresh_data(response.json())\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\nimport time\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Monitor cache performance\ncache_hits = 0\ncache_misses = 0\n\nfor i in range(100):\n    response = session.get(\"https://api.example.com/popular-data\")\n\n    if response.headers.get(\"X-Hishel-From-Cache\") == \"true\":\n        cache_hits += 1\n    else:\n        cache_misses += 1\n\nhit_rate = (cache_hits / 100) * 100\nprint(f\"Cache hit rate: {hit_rate}%\")\n\n# Conditional processing based on cache status\nresponse = session.get(\"https://api.example.com/user/profile\")\n\nif response.headers.get(\"X-Hishel-From-Cache\") == \"true\":\n    print(\"Using cached profile - may be slightly outdated\")\nelse:\n    print(\"Fresh profile data from server\")\n    # Trigger additional processing for fresh data\n    process_fresh_data(response.json())\n</code></pre>"},{"location":"beta/metadata/#hishel_revalidated","title":"hishel_revalidated","text":"<p>Type: <code>bool | None</code></p> <p>Description: Indicates whether a stale cached response was revalidated with the origin server. When <code>True</code>, the response was in cache but required validation (typically resulting in a 304 Not Modified response).</p> <p>Use Cases:</p> <ul> <li>Monitor revalidation frequency</li> <li>Debug cache freshness logic</li> <li>Track conditional request behavior</li> <li>Optimize cache TTL settings</li> </ul> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\nresponse = client.get(\"https://api.example.com/data\")\n\n# Check if cached response was revalidated\nif response.extensions.get(\"hishel_revalidated\"):\n    print(\"Response was revalidated (304 Not Modified)\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\nresponse = session.get(\"https://api.example.com/data\")\n\n# Check if cached response was revalidated\nif response.headers.get(\"X-Hishel-Revalidated\") == \"true\":\n    print(\"Response was revalidated (304 Not Modified)\")\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Track different cache states\nresponse = client.get(\"https://api.example.com/articles\")\n\nfrom_cache = response.extensions.get(\"hishel_from_cache\")\nrevalidated = response.extensions.get(\"hishel_revalidated\")\n\nif from_cache and not revalidated:\n    print(\"\u2713 Fresh cache hit - no server contact\")\nelif from_cache and revalidated:\n    print(\"\u21bb Stale cache revalidated - saved bandwidth\")\nelse:\n    print(\"\u2717 Cache miss - full response from server\")\n\n# Analyze caching patterns\nrevalidation_count = 0\ntotal_requests = 100\n\nfor i in range(total_requests):\n    resp = client.get(\"https://api.example.com/data\")\n    if resp.extensions.get(\"hishel_revalidated\"):\n        revalidation_count += 1\n\nprint(f\"Revalidation rate: {(revalidation_count/total_requests)*100}%\")\nprint(\"Tip: High revalidation rate might indicate TTL is too short\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Track different cache states\nresponse = session.get(\"https://api.example.com/articles\")\n\nfrom_cache = response.headers.get(\"X-Hishel-From-Cache\") == \"true\"\nrevalidated = response.headers.get(\"X-Hishel-Revalidated\") == \"true\"\n\nif from_cache and not revalidated:\n    print(\"\u2713 Fresh cache hit - no server contact\")\nelif from_cache and revalidated:\n    print(\"\u21bb Stale cache revalidated - saved bandwidth\")\nelse:\n    print(\"\u2717 Cache miss - full response from server\")\n\n# Analyze caching patterns\nrevalidation_count = 0\ntotal_requests = 100\n\nfor i in range(total_requests):\n    resp = session.get(\"https://api.example.com/data\")\n    if resp.headers.get(\"X-Hishel-Revalidated\") == \"true\":\n        revalidation_count += 1\n\nprint(f\"Revalidation rate: {(revalidation_count/total_requests)*100}%\")\nprint(\"Tip: High revalidation rate might indicate TTL is too short\")\n</code></pre>"},{"location":"beta/metadata/#hishel_spec_ignored","title":"hishel_spec_ignored","text":"<p>Type: <code>bool | None</code></p> <p>Description: Indicates whether RFC 9111 caching specification was ignored for this response. When <code>True</code>, the response was cached despite having directives that would normally prevent caching (like <code>Cache-Control: no-store</code>).</p> <p>Use Cases:</p> <ul> <li>Verify <code>hishel_spec_ignore</code> worked as expected</li> <li>Audit which responses bypass standard caching rules</li> <li>Debug forced caching behavior</li> </ul> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Force cache a response\nresponse = client.get(\n    \"https://api.example.com/no-cache-endpoint\",\n    extensions={\"hishel_spec_ignore\": True}\n)\n\n# Verify spec was ignored\nif response.extensions.get(\"hishel_spec_ignored\"):\n    print(\"\u2713 Caching rules were bypassed as requested\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Force cache a response\nresponse = session.get(\n    \"https://api.example.com/no-cache-endpoint\",\n    headers={\"X-Hishel-Spec-Ignore\": \"true\"}\n)\n\n# Verify spec was ignored\nif response.headers.get(\"X-Hishel-Spec-Ignored\") == \"true\":\n    print(\"\u2713 Caching rules were bypassed as requested\")\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Testing/Development: Force cache responses without proper headers\nresponse = client.get(\n    \"https://api.example.com/dev-endpoint\",\n    extensions={\n        \"hishel_spec_ignore\": True,\n        \"hishel_ttl\": 300\n    }\n)\n\n# Log which responses bypass caching rules\nif response.extensions.get(\"hishel_spec_ignored\"):\n    print(f\"\u26a0\ufe0f  Spec ignored for: {response.url}\")\n    print(f\"   Original Cache-Control: {response.headers.get('cache-control')}\")\n    print(\"   Response cached anyway\")\n\n# Audit forced caching\nforced_cache_urls = []\n\nfor url in api_endpoints:\n    resp = client.get(url, extensions={\"hishel_spec_ignore\": True})\n    if resp.extensions.get(\"hishel_spec_ignored\"):\n        forced_cache_urls.append(url)\n\nprint(f\"Total endpoints with forced caching: {len(forced_cache_urls)}\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Testing/Development: Force cache responses without proper headers\nresponse = session.get(\n    \"https://api.example.com/dev-endpoint\",\n    headers={\n        \"X-Hishel-Spec-Ignore\": \"true\",\n        \"X-Hishel-Ttl\": \"300\"\n    }\n)\n\n# Log which responses bypass caching rules\nif response.headers.get(\"X-Hishel-Spec-Ignored\") == \"true\":\n    print(f\"\u26a0\ufe0f  Spec ignored for: {response.url}\")\n    print(f\"   Original Cache-Control: {response.headers.get('cache-control')}\")\n    print(\"   Response cached anyway\")\n\n# Audit forced caching\nforced_cache_urls = []\n\nfor url in api_endpoints:\n    resp = session.get(url, headers={\"X-Hishel-Spec-Ignore\": \"true\"})\n    if resp.headers.get(\"X-Hishel-Spec-Ignored\") == \"true\":\n        forced_cache_urls.append(url)\n\nprint(f\"Total endpoints with forced caching: {len(forced_cache_urls)}\")\n</code></pre>"},{"location":"beta/metadata/#hishel_stored","title":"hishel_stored","text":"<p>Type: <code>bool | None</code></p> <p>Description: Indicates whether the response was successfully stored in cache. When <code>True</code>, the response met all caching requirements and was saved. When <code>False</code>, the response was not cacheable (e.g., due to <code>Cache-Control: no-store</code>).</p> <p>Use Cases:</p> <ul> <li>Verify responses are being cached</li> <li>Debug why responses aren't cached</li> <li>Monitor cache storage success rate</li> <li>Validate caching configuration</li> </ul> <p>Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\nresponse = client.get(\"https://api.example.com/data\")\n\n# Check if response was cached\nif response.extensions.get(\"hishel_stored\"):\n    print(\"\u2713 Response stored in cache\")\nelse:\n    print(\"\u2717 Response not cached\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\nresponse = session.get(\"https://api.example.com/data\")\n\n# Check if response was cached\nif response.headers.get(\"X-Hishel-Stored\") == \"true\":\n    print(\"\u2713 Response stored in cache\")\nelse:\n    print(\"\u2717 Response not cached\")\n</code></pre> <p>Real-World Example:</p> httpxrequests <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Debug why responses aren't being cached\nresponse = client.get(\"https://api.example.com/user/profile\")\n\nstored = response.extensions.get(\"hishel_stored\")\nfrom_cache = response.extensions.get(\"hishel_from_cache\")\n\nif not stored and not from_cache:\n    print(\"\u26a0\ufe0f  Response not cached!\")\n    print(f\"   Status: {response.status_code}\")\n    print(f\"   Cache-Control: {response.headers.get('cache-control')}\")\n    print(\"   Check server caching headers\")\n\n# Monitor cache storage rate\nstored_count = 0\nnot_stored_count = 0\n\ntest_urls = [\n    \"https://api.example.com/static\",\n    \"https://api.example.com/dynamic\",\n    \"https://api.example.com/private\",\n]\n\nfor url in test_urls:\n    resp = client.get(url)\n    if resp.extensions.get(\"hishel_stored\"):\n        stored_count += 1\n        print(f\"\u2713 {url} - cached\")\n    else:\n        not_stored_count += 1\n        print(f\"\u2717 {url} - not cached\")\n\nstorage_rate = (stored_count / len(test_urls)) * 100\nprint(f\"\\nStorage rate: {storage_rate}%\")\n\n# Validate caching after configuration changes\nresponse = client.get(\n    \"https://api.example.com/test\",\n    extensions={\"hishel_ttl\": 600}\n)\n\nif response.extensions.get(\"hishel_stored\"):\n    print(\"\u2713 Configuration working - responses are being cached\")\nelse:\n    print(\"\u2717 Configuration issue - check TTL and cache headers\")\n</code></pre> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"http://\", CacheAdapter())\nsession.mount(\"https://\", CacheAdapter())\n\n# Debug why responses aren't being cached\nresponse = session.get(\"https://api.example.com/user/profile\")\n\nstored = response.headers.get(\"X-Hishel-Stored\") == \"true\"\nfrom_cache = response.headers.get(\"X-Hishel-From-Cache\") == \"true\"\n\nif not stored and not from_cache:\n    print(\"\u26a0\ufe0f  Response not cached!\")\n    print(f\"   Status: {response.status_code}\")\n    print(f\"   Cache-Control: {response.headers.get('cache-control')}\")\n    print(\"   Check server caching headers\")\n\n# Monitor cache storage rate\nstored_count = 0\nnot_stored_count = 0\n\ntest_urls = [\n    \"https://api.example.com/static\",\n    \"https://api.example.com/dynamic\",\n    \"https://api.example.com/private\",\n]\n\nfor url in test_urls:\n    resp = session.get(url)\n    if resp.headers.get(\"X-Hishel-Stored\") == \"true\":\n        stored_count += 1\n        print(f\"\u2713 {url} - cached\")\n    else:\n        not_stored_count += 1\n        print(f\"\u2717 {url} - not cached\")\n\nstorage_rate = (stored_count / len(test_urls)) * 100\nprint(f\"\\nStorage rate: {storage_rate}%\")\n\n# Validate caching after configuration changes\nresponse = session.get(\n    \"https://api.example.com/test\",\n    headers={\"X-Hishel-Ttl\": \"600\"}\n)\n\nif response.headers.get(\"X-Hishel-Stored\") == \"true\":\n    print(\"\u2713 Configuration working - responses are being cached\")\nelse:\n    print(\"\u2717 Configuration issue - check TTL and cache headers\")\n</code></pre>"},{"location":"beta/metadata/#metadata-reference-summary","title":"Metadata Reference Summary","text":""},{"location":"beta/metadata/#setting-request-metadata","title":"Setting Request Metadata","text":"Library Method Format httpx <code>extensions</code> (recommended) <code>extensions={\"hishel_ttl\": 3600}</code> (Python types) httpx <code>headers</code> <code>headers={\"X-Hishel-Ttl\": \"3600\"}</code> (string values) requests <code>headers</code> <code>headers={\"X-Hishel-Ttl\": \"3600\"}</code> (string values)"},{"location":"beta/metadata/#request-metadata-fields","title":"Request Metadata Fields","text":"Field Header Type Description <code>hishel_ttl</code> <code>X-Hishel-Ttl</code> <code>float</code> / <code>string</code> Custom TTL in seconds <code>hishel_refresh_ttl_on_access</code> <code>X-Hishel-Refresh-Ttl-On-Access</code> <code>bool</code> / <code>string</code> Enable sliding expiration <code>hishel_spec_ignore</code> <code>X-Hishel-Spec-Ignore</code> <code>bool</code> / <code>string</code> Ignore RFC 9111 rules <code>hishel_body_key</code> <code>X-Hishel-Body-Key</code> <code>bool</code> / <code>string</code> Include body in cache key"},{"location":"beta/metadata/#reading-response-metadata","title":"Reading Response Metadata","text":"Library Method Example httpx <code>extensions</code> dict <code>response.extensions.get(\"hishel_from_cache\")</code> httpx <code>headers</code> <code>response.headers.get(\"X-Hishel-From-Cache\")</code> requests <code>headers</code> <code>response.headers.get(\"X-Hishel-From-Cache\")</code>"},{"location":"beta/metadata/#response-metadata-fields","title":"Response Metadata Fields","text":"Field Header Type Description <code>hishel_from_cache</code> <code>X-Hishel-From-Cache</code> <code>bool</code> / <code>string</code> Response from cache <code>hishel_revalidated</code> <code>X-Hishel-Revalidated</code> <code>bool</code> / <code>string</code> Response was revalidated <code>hishel_spec_ignored</code> <code>X-Hishel-Spec-Ignored</code> <code>bool</code> / <code>string</code> Spec was ignored <code>hishel_stored</code> <code>X-Hishel-Stored</code> <code>bool</code> / <code>string</code> Response was stored <p>Type Differences</p> <ul> <li>httpx extensions: Native Python types (<code>bool</code>, <code>float</code>)</li> <li>httpx/requests headers: String values (<code>\"true\"</code>, <code>\"false\"</code>, <code>\"3600\"</code>)</li> </ul>"},{"location":"beta/specification/","title":"HTTP Caching State Machine","text":"<p>Hishel provides a sans-I/O implementation of the HTTP caching specification (RFC 9111), allowing you to integrate RFC-compliant caching into any Python application\u2014whether client-side or server-side.</p> <p>The implementation uses an event-driven state machine that tells you exactly what to do next based on HTTP caching rules. You handle all I/O (network requests, storage operations), while the state machine ensures RFC 9111 compliance.</p>"},{"location":"beta/specification/#quick-start","title":"Quick Start","text":"<pre><code>from hishel.beta import (\n    # States\n    IdleClient,\n    CacheMiss,\n    FromCache,\n    NeedRevalidation,\n    NeedToBeUpdated,\n    StoreAndUse,\n    CouldNotBeStored,\n    InvalidatePairs,\n\n    # Configuration\n    CacheOptions,\n\n    # Helper\n    create_idle_state\n)\n\n# Create an idle state (starting point)\nstate = create_idle_state(\"client\")  # \"client\" or \"server\" (server in development)\n\n# The state machine guides you through the caching logic\nnext_state = state.next(request, associated_pairs=[])\n\n# Each state has a specific signature for its next() method\n# Type hints tell you exactly what parameters are needed\n</code></pre>"},{"location":"beta/specification/#how-it-works","title":"How It Works","text":"<p>The state machine exposes RFC 9111 logic as a series of states and transitions. Each state represents a specific situation in the HTTP caching lifecycle:</p> <ol> <li>You provide: HTTP requests, responses, and cached data</li> <li>State machine decides: What action to take next</li> <li>You execute: The I/O operations (network, storage)</li> <li>State machine validates: Ensures RFC compliance</li> </ol> <p>This design allows you to build HTTP caches that are: - \u2705 Correct: Fully compliant with RFC 9111 - \u2705 Testable: Sans-I/O design enables easy testing - \u2705 Flexible: Works with any I/O library or framework - \u2705 Type-safe: Fully typed with clear state transitions</p>"},{"location":"beta/specification/#state-transitions","title":"State Transitions","text":"<p>The state machine follows a clear flow through different states based on HTTP caching rules defined in RFC 9111. Here's the complete transition map:</p> <pre><code>graph TB\n  IdleClient[IdleClient&lt;br/&gt;Starting Point] --&gt;|No cache or&lt;br/&gt;uncacheable| CacheMiss[CacheMiss&lt;br/&gt;Forward to Origin]\n  IdleClient --&gt;|Fresh cache| FromCache[FromCache&lt;br/&gt;Use Cached Response]\n  IdleClient --&gt;|Stale cache| NeedRevalidation[NeedRevalidation&lt;br/&gt;Validate with Origin]\n\n  CacheMiss --&gt;|Response&lt;br/&gt;cacheable| StoreAndUse[StoreAndUse&lt;br/&gt;Store &amp; Return]\n  CacheMiss --&gt;|Response not&lt;br/&gt;cacheable| CouldNotBeStored[CouldNotBeStored&lt;br/&gt;Return without storing]\n\n  NeedRevalidation --&gt;|304 Not&lt;br/&gt;Modified| NeedToBeUpdated[NeedToBeUpdated&lt;br/&gt;Freshen Cache]\n  NeedRevalidation --&gt;|2xx/5xx&lt;br/&gt;Response| InvalidatePairs[InvalidatePairs&lt;br/&gt;Delete Old Cache]\n\n  InvalidatePairs --&gt; CacheMiss\n  NeedToBeUpdated --&gt; FromCache\n\n  FromCache -.-&gt;|Terminal| End1((End))\n  StoreAndUse -.-&gt;|Terminal| End2((End))\n  CouldNotBeStored -.-&gt;|Terminal| End3((End))\n\n  style IdleClient fill:#e1f5ff\n  style FromCache fill:#c8e6c9\n  style StoreAndUse fill:#c8e6c9\n  style CouldNotBeStored fill:#ffcdd2\n  style NeedRevalidation fill:#fff9c4\n  style InvalidatePairs fill:#ffe0b2</code></pre> <p>Legend: - Blue: Entry state (IdleClient) - Green: Success states (FromCache, StoreAndUse) - Red: Failure state (CouldNotBeStored) - Yellow: Intermediate states requiring I/O - Orange: Action states (InvalidatePairs)</p>"},{"location":"beta/specification/#state-flow-examples","title":"State Flow Examples","text":""},{"location":"beta/specification/#example-1-fresh-cache-hit","title":"Example 1: Fresh Cache Hit","text":"<p><pre><code>Request \u2192 IdleClient \u2192 FromCache \u2192 End\n</code></pre> Scenario: Client requests <code>/api/users</code>, cache has fresh response Actions: Return cached response immediately, no origin contact</p>"},{"location":"beta/specification/#example-2-cache-miss-and-store","title":"Example 2: Cache Miss and Store","text":"<p><pre><code>Request \u2192 IdleClient \u2192 CacheMiss \u2192 StoreAndUse \u2192 End\n</code></pre> Scenario: First request for <code>/api/products</code> Actions: Forward to origin, receive cacheable response, store it, return to client</p>"},{"location":"beta/specification/#example-3-cache-miss-but-cannot-store","title":"Example 3: Cache Miss but Cannot Store","text":"<p><pre><code>Request \u2192 IdleClient \u2192 CacheMiss \u2192 CouldNotBeStored \u2192 End\n</code></pre> Scenario: Request <code>/api/private</code> with Authorization header, response has no cache directives Actions: Forward to origin, receive response with <code>no-store</code>, return without caching</p>"},{"location":"beta/specification/#example-4-successful-revalidation-304","title":"Example 4: Successful Revalidation (304)","text":"<p><pre><code>Request \u2192 IdleClient \u2192 NeedRevalidation \u2192 NeedToBeUpdated \u2192 FromCache \u2192 End\n</code></pre> Scenario: Cached <code>/api/data</code> is stale, origin confirms it's unchanged Actions: Send conditional request, receive 304, update cache metadata, return cached content</p>"},{"location":"beta/specification/#example-5-failed-revalidation-200","title":"Example 5: Failed Revalidation (200)","text":"<p><pre><code>Request \u2192 IdleClient \u2192 NeedRevalidation \u2192 InvalidatePairs \u2192 CacheMiss \u2192 StoreAndUse \u2192 End\n</code></pre> Scenario: Cached <code>/api/status</code> is stale, origin returns new content Actions: Send conditional request, receive 200 with new content, delete old cache, store new response</p> <pre><code>from hishel.beta import create_idle_state\n\nstate = create_idle_state(\"client\")  # client or server (server still in development)\n\n# signature will look like:\n#   (method) def next(\n#       request: Request,\n#       associated_pairs: list[CompletePair]\n#  )  -&gt; (CacheMiss | FromCache | NeedRevalidation)\nnext_state = state.next(...)\n</code></pre> <p>In this example, <code>next_state</code> will be one of <code>CacheMiss</code>, <code>FromCache</code>, or <code>NeedRevalidation</code>, each exposing the appropriate signature for its next method.</p>"},{"location":"beta/specification/#states","title":"States","text":"<p>The state machine implements RFC 9111 through a series of well-defined states. Each state represents a specific point in the HTTP caching lifecycle and determines the next action to take.</p>"},{"location":"beta/specification/#idleclient","title":"IdleClient","text":"<p>What it means: The starting point of the cache state machine. This state represents an idle client that has received a request and needs to determine whether it can be satisfied from cache, needs revalidation, or must be forwarded to the origin server.</p> <p>When you're in this state: </p> <ul> <li>A new HTTP request has been received</li> <li>You need to check if cached responses exist</li> <li>You need to evaluate if cached responses can be used</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 FromCache: A fresh cached response exists and can be used immediately without contacting the origin server</li> <li>\u2192 NeedRevalidation: A stale cached response exists that requires validation with the origin server before use</li> <li>\u2192 CacheMiss: No suitable cached response exists, or the request cannot be satisfied from cache</li> </ul> <p>RFC Reference: Section 4 - Constructing Responses from Caches</p> <p>Example: <pre><code>from hishel.beta import IdleClient, CacheOptions\n\n# Create idle state\nidle = IdleClient(options=CacheOptions())\n\n# Transition based on request and cached pairs\nnext_state = idle.next(request, associated_pairs=[])\n# Returns: CacheMiss | FromCache | NeedRevalidation\n</code></pre></p>"},{"location":"beta/specification/#cachemiss","title":"CacheMiss","text":"<p>What it means: The request cannot be satisfied from cache and must be forwarded to the origin server. After receiving the origin's response, this state evaluates whether the response can be stored in the cache.</p> <p>When you're in this state:</p> <ul> <li>No suitable cached response exists for the request</li> <li>You've received a response from the origin server</li> <li>You need to determine if this response should be cached</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 StoreAndUse: The response meets all RFC 9111 storage requirements and should be cached</li> <li>\u2192 CouldNotBeStored: The response fails one or more storage requirements and cannot be cached</li> </ul> <p>Storage Requirements Checked:</p> <ol> <li>Request method is understood by the cache</li> <li>Response status code is final (not 1xx)</li> <li>Cache understands the response status code</li> <li>No <code>no-store</code> directive present</li> <li><code>private</code> directive allows storage (for shared caches)</li> <li><code>Authorization</code> header is properly handled</li> <li>Response contains explicit caching information OR is heuristically cacheable</li> </ol> <p>RFC Reference: Section 3 - Storing Responses in Caches</p> <p>Example: <pre><code>from hishel.beta import CacheMiss\n\n# After forwarding request to origin\ncache_miss = CacheMiss(request=request, options=options)\n\n# Evaluate response for storage\nnext_state = cache_miss.next(response, pair_id=uuid.uuid4())\n# Returns: StoreAndUse | CouldNotBeStored\n</code></pre></p>"},{"location":"beta/specification/#needrevalidation","title":"NeedRevalidation","text":"<p>What it means: One or more stale cached responses exist for the request, but they cannot be used without validation. A conditional request must be sent to the origin server to check if the cached content is still valid.</p> <p>When you're in this state:</p> <ul> <li>Cached responses exist but are stale (past their freshness lifetime)</li> <li>The responses have validators (ETag or Last-Modified)</li> <li>You've sent a conditional request to the origin (If-None-Match or If-Modified-Since)</li> <li>You're waiting for the validation response</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 NeedToBeUpdated: Origin responds with 304 Not Modified - cached responses are still valid and can be freshened</li> <li>\u2192 InvalidatePairs + CacheMiss: Origin responds with 2xx/5xx - cached responses are outdated and must be replaced</li> <li>\u2192 CacheMiss: No matching responses found during the freshening process</li> </ul> <p>Validation Process:</p> <ol> <li>Client sends conditional request with validators from cached response</li> <li>Origin server checks if content has changed</li> <li>304 response: Content unchanged, update cache metadata</li> <li>2xx/5xx response: Content changed or error, invalidate old cache and store new response</li> </ol> <p>RFC Reference: Section 4.3 - Validation</p> <p>Example: <pre><code>from hishel.beta import NeedRevalidation\n\n# After detecting stale cache\nneed_revalidation = NeedRevalidation(\n    request=conditional_request,\n    original_request=original_request,\n    revalidating_pairs=[stale_pair],\n    options=options\n)\n\n# Handle validation response\nnext_state = need_revalidation.next(validation_response)\n# Returns: NeedToBeUpdated | InvalidatePairs | CacheMiss\n</code></pre></p>"},{"location":"beta/specification/#fromcache","title":"FromCache","text":"<p>What it means: A suitable cached response was found and can be used immediately to satisfy the request. No communication with the origin server is needed.</p> <p>When you're in this state: - A fresh cached response exists for the request - The cached response matches all request requirements (Vary headers, etc.) - The response is within its freshness lifetime OR stale responses are allowed</p> <p>Transitions:</p> <ul> <li>\u2192 None: This is a terminal state. Use the cached response to satisfy the request.</li> </ul> <p>What to do:</p> <ol> <li>Retrieve the cached response</li> <li>Update the Age header to reflect current age</li> <li>Return the response to the client</li> <li>No further state transitions needed</li> </ol> <p>RFC Reference: Section 4.2 - Freshness</p> <p>Example: <pre><code>from hishel.beta import FromCache\n\n# When a fresh response is found\nfrom_cache = FromCache(pair=cached_pair, options=options)\n\n# This is a terminal state\nassert from_cache.next() is None\n\n# Use cached_pair.response to satisfy the request\n</code></pre></p>"},{"location":"beta/specification/#needtobeupdated","title":"NeedToBeUpdated","text":"<p>What it means: The origin server responded with 304 Not Modified during revalidation. The cached responses are still valid but need their metadata refreshed with information from the 304 response.</p> <p>When you're in this state:</p> <ul> <li>You received a 304 Not Modified response</li> <li>One or more cached responses match the validators</li> <li>The cached content is still valid but metadata needs updating</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 FromCache: After updating cached responses, use them to satisfy the request</li> </ul> <p>Update Process:</p> <ol> <li>Match cached responses using validators (ETag or Last-Modified)</li> <li>Update matched responses with new headers from 304 response</li> <li>Preserve the cached response body (content hasn't changed)</li> <li>Update freshness information (Date, Cache-Control, Expires)</li> </ol> <p>RFC Reference: Section 4.3.4 - Freshening Stored Responses</p> <p>Example: <pre><code>from hishel.beta import NeedToBeUpdated\n\n# After 304 Not Modified\nneed_update = NeedToBeUpdated(\n    updating_pairs=[cached_pair],\n    original_request=original_request,\n    options=options\n)\n\n# Transition to FromCache\nnext_state = need_update.next()\n# Returns: FromCache\n</code></pre></p>"},{"location":"beta/specification/#storeanduse","title":"StoreAndUse","text":"<p>What it means: The response from the origin server meets all RFC 9111 storage requirements and should be saved to the cache. This is a terminal state indicating successful caching.</p> <p>When you're in this state:</p> <ul> <li>You received a response from the origin server</li> <li>The response passed all storage validation checks</li> <li>The response should be cached for future requests</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 None: This is a terminal state. Store the response and use it to satisfy the request.</li> </ul> <p>What to do:</p> <ol> <li>Store the request-response pair in your cache storage</li> <li>Store any stream data (request/response bodies)</li> <li>Return the response to the client</li> <li>The response is now available for future requests</li> </ol> <p>RFC Reference: Section 3 - Storing Responses in Caches</p> <p>Example: <pre><code>from hishel.beta import StoreAndUse\n\n# After determining response is cacheable\nstore_and_use = StoreAndUse(\n    pair_id=pair_id,\n    response=response,\n    options=options\n)\n\n# This is a terminal state\nassert store_and_use.next() is None\n\n# Store the pair and return the response\n</code></pre></p>"},{"location":"beta/specification/#couldnotbestored","title":"CouldNotBeStored","text":"<p>What it means: The response from the origin server does not meet RFC 9111 storage requirements and cannot be cached. This is a terminal state indicating the response should be used but not stored.</p> <p>When you're in this state:</p> <ul> <li>You received a response from the origin server</li> <li>The response failed one or more storage validation checks</li> <li>The response should be returned to the client but not cached</li> </ul> <p>Common Reasons:</p> <ul> <li>Contains <code>no-store</code> cache directive</li> <li>Contains <code>private</code> directive (for shared caches)</li> <li>Method not supported for caching</li> <li>Status code not cacheable</li> <li><code>Authorization</code> header without explicit caching permission</li> <li>No explicit caching directives and not heuristically cacheable</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 None: This is a terminal state. Use the response without storing it.</li> </ul> <p>What to do:</p> <ol> <li>Return the response to the client</li> <li>Do NOT store it in cache</li> <li>Future identical requests will also result in cache miss</li> </ol> <p>RFC Reference: Section 3 - Storing Responses in Caches</p> <p>Example: <pre><code>from hishel.beta import CouldNotBeStored\n\n# After determining response is not cacheable\ncould_not_store = CouldNotBeStored(\n    response=response,\n    pair_id=pair_id,\n    options=options\n)\n\n# This is a terminal state\nassert could_not_store.next() is None\n\n# Return response without storing\n</code></pre></p>"},{"location":"beta/specification/#invalidatepairs","title":"InvalidatePairs","text":"<p>What it means: One or more cached response pairs need to be invalidated (deleted) from the cache before proceeding to the next state. This is a wrapper state that performs cleanup before transitioning.</p> <p>When you're in this state:</p> <ul> <li>Outdated cached responses need to be removed</li> <li>You're proceeding to another state after cleanup</li> <li>This typically occurs during revalidation when new responses replace old ones</li> </ul> <p>Transitions:</p> <ul> <li>\u2192 next_state: After invalidating pairs, transition to the wrapped next state (typically <code>CacheMiss</code> or <code>NeedToBeUpdated</code>)</li> </ul> <p>Common Scenarios:</p> <ol> <li>After 2xx response during revalidation: Old cached responses are outdated, invalidate them before storing new response</li> <li>After 5xx error during revalidation: Server error invalidates cached responses</li> <li>During freshening: Responses that don't match validators need removal</li> </ol> <p>What to do:</p> <ol> <li>Delete the specified pairs from cache storage</li> <li>Delete associated stream data</li> <li>Transition to the next state specified</li> </ol> <p>Example: <pre><code>from hishel.beta import InvalidatePairs, CacheMiss\n\n# During revalidation with new response\ninvalidate = InvalidatePairs(\n    pair_ids=[old_pair_id1, old_pair_id2],\n    next_state=CacheMiss(request=request, options=options),\n    options=options\n)\n\n# Get next state after invalidation\nnext_state = invalidate.next()\n# Returns: The wrapped next_state (e.g., CacheMiss)\n</code></pre></p>"},{"location":"beta/specification/#configuration","title":"Configuration","text":"<p>You can pass an options parameter to any state to control how it behaves in certain situations. This was primarily added to allow configuration for cases where the RFC does not explicitly specify the behavior. In some places, the RFC might say that a cache MIGHT do something; the <code>options</code> parameter lets you define how to handle such cases.</p> <p>Import the CacheOptions class and pass it to the State, like so:</p> <pre><code>from hishel.beta import IdleClient, CacheOptions\n\nstate = IdleClient(\n  options=CacheOptions(\n    allow_stale=True\n  )\n)\n</code></pre>"},{"location":"beta/storages/","title":"Storage Backends","text":"<p>Hishel provides storage backends for persisting HTTP request-response pairs. These storages are designed to work with the RFC 9111-compliant state machine and support both synchronous and asynchronous operations.</p>"},{"location":"beta/storages/#overview","title":"Overview","text":"<p>Storage backends handle:</p> <ul> <li>\u2705 Pair Management: Store incomplete and complete request-response pairs</li> <li>\u2705 Stream Handling: Efficiently store and retrieve large request/response bodies</li> <li>\u2705 TTL Management: Automatic expiration and cleanup of old entries</li> <li>\u2705 Soft Deletion: Mark entries as deleted without immediate removal</li> <li>\u2705 Cache Keys: Group multiple pairs under a single cache key</li> </ul>"},{"location":"beta/storages/#available-storages","title":"Available Storages","text":"<p>Currently available: - SQLite Storage - Persistent storage using SQLite database (async and sync)</p> <p>Coming soon:</p> <ul> <li>Memory Storage - In-memory storage for testing and non-persistent caching</li> <li>any more...?</li> </ul>"},{"location":"beta/storages/#sqlite-storage","title":"SQLite Storage","text":"<p>SQLite storage provides persistent, file-based caching with excellent performance characteristics. It uses two tables: one for request-response pairs and another for streaming data chunks.</p>"},{"location":"beta/storages/#initialization","title":"Initialization","text":"AsyncSync <pre><code>from hishel.beta import AsyncSqliteStorage\n\n# Default configuration (creates hishel_cache.db in cache directory)\nstorage = AsyncSqliteStorage()\n\n# Custom database path\nstorage = AsyncSqliteStorage(database_path=\"my_cache.db\")\n\n# With TTL configuration\nstorage = AsyncSqliteStorage(\n    default_ttl=3600.0,  # 1 hour default TTL\n    refresh_ttl_on_access=True  # Reset TTL on access\n)\n\n# Custom connection (advanced usage)\nimport anysqlite\nconn = await anysqlite.connect(\"custom_cache.db\")\nstorage = AsyncSqliteStorage(connection=conn)\n</code></pre> <pre><code>from hishel.beta import SyncSqliteStorage\n\n# Default configuration (creates hishel_cache.db in cache directory)\nstorage = SyncSqliteStorage()\n\n# Custom database path\nstorage = SyncSqliteStorage(database_path=\"my_cache.db\")\n\n# With TTL configuration\nstorage = SyncSqliteStorage(\n    default_ttl=3600.0,  # 1 hour default TTL\n    refresh_ttl_on_access=True  # Reset TTL on access\n)\n\n# Custom connection (advanced usage)\nimport sqlite3\nconn = sqlite3.connect(\"custom_cache.db\")\nstorage = SyncSqliteStorage(connection=conn)\n</code></pre>"},{"location":"beta/storages/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>connection</code> <code>Connection | None</code> <code>None</code> Pre-existing database connection. If <code>None</code>, a new connection is created. <code>database_path</code> <code>str</code> <code>\"hishel_cache.db\"</code> Path to the SQLite database file (relative to cache directory). <code>default_ttl</code> <code>float | None</code> <code>None</code> Default time-to-live in seconds for cached entries. <code>None</code> means no expiration. <code>refresh_ttl_on_access</code> <code>bool</code> <code>True</code> Whether to reset the TTL when an entry is accessed."},{"location":"beta/storages/#basic-usage","title":"Basic Usage","text":""},{"location":"beta/storages/#creating-pairs","title":"Creating Pairs","text":"<p>A \"pair\" consists of an HTTP request and response. Storage operations start by creating an incomplete pair (request only), then adding the response later.</p> AsyncSync <pre><code>from hishel.beta import AsyncSqliteStorage, Request, Headers\n\nstorage = AsyncSqliteStorage()\n\n# Create incomplete pair with request\nincomplete_pair = await storage.create_pair(\n    request=Request(\n        method=\"GET\",\n        url=\"https://api.example.com/users\",\n        headers=Headers({\"User-Agent\": \"MyApp/1.0\"})\n    )\n)\n\n# incomplete_pair has:\n# - id: UUID\n# - request: Request\n# - meta: PairMeta (created_at timestamp)\n\nprint(f\"Created pair with ID: {incomplete_pair.id}\")\n</code></pre> <pre><code>from hishel.beta import SyncSqliteStorage, Request, Headers\n\nstorage = SyncSqliteStorage()\n\n# Create incomplete pair with request\nincomplete_pair = storage.create_pair(\n    request=Request(\n        method=\"GET\",\n        url=\"https://api.example.com/users\",\n        headers=Headers({\"User-Agent\": \"MyApp/1.0\"})\n    )\n)\n\n# incomplete_pair has:\n# - id: UUID\n# - request: Request\n# - meta: PairMeta (created_at timestamp)\n\nprint(f\"Created pair with ID: {incomplete_pair.id}\")\n</code></pre>"},{"location":"beta/storages/#adding-responses","title":"Adding Responses","text":"<p>After receiving a response from the origin server, complete the pair by adding the response.</p> AsyncSync <pre><code>from hishel.beta import Response, Headers\n\n# Add response to complete the pair\ncomplete_pair = await storage.add_response(\n    pair_id=incomplete_pair.id,\n    response=Response(\n        status_code=200,\n        headers=Headers({\"Content-Type\": \"application/json\"}),\n        stream=...,  # Response body stream\n    ),\n    key=\"GET:https://api.example.com/users\"  # Cache key\n)\n\n# complete_pair has:\n# - id: UUID\n# - request: Request\n# - response: Response\n# - cache_key: bytes\n# - meta: PairMeta\n\nprint(f\"Stored response with status {complete_pair.response.status_code}\")\n</code></pre> <pre><code>from hishel.beta import Response, Headers\n\n# Add response to complete the pair\ncomplete_pair = storage.add_response(\n    pair_id=incomplete_pair.id,\n    response=Response(\n        status_code=200,\n        headers=Headers({\"Content-Type\": \"application/json\"}),\n        stream=...,  # Response body stream\n    ),\n    key=\"GET:https://api.example.com/users\"  # Cache key\n)\n\n# complete_pair has:\n# - id: UUID\n# - request: Request\n# - response: Response\n# - cache_key: bytes\n# - meta: PairMeta\n\nprint(f\"Stored response with status {complete_pair.response.status_code}\")\n</code></pre>"},{"location":"beta/storages/#retrieving-cached-pairs","title":"Retrieving Cached Pairs","text":"<p>Retrieve all complete pairs associated with a cache key.</p> AsyncSync <pre><code># Get all pairs for a cache key\ncache_key = \"GET:https://api.example.com/users\"\npairs = await storage.get_pairs(cache_key)\n\n# pairs is a list of CompletePair objects\nfor pair in pairs:\n    print(f\"Cached response: {pair.response.status_code}\")\n\n    # Access request/response bodies through streams\n    async for chunk in pair.request.aiter_stream():\n        print(f\"Request chunk: {chunk}\")\n\n    async for chunk in pair.response.aiter_stream():\n        print(f\"Response chunk: {chunk}\")\n</code></pre> <pre><code># Get all pairs for a cache key\ncache_key = \"GET:https://api.example.com/users\"\npairs = storage.get_pairs(cache_key)\n\n# pairs is a list of CompletePair objects\nfor pair in pairs:\n    print(f\"Cached response: {pair.response.status_code}\")\n\n    # Access request/response bodies through streams\n    for chunk in pair.request.iter_stream():\n        print(f\"Request chunk: {chunk}\")\n\n    for chunk in pair.response.iter_stream():\n        print(f\"Response chunk: {chunk}\")\n</code></pre>"},{"location":"beta/storages/#updating-pairs","title":"Updating Pairs","text":"<p>Update an existing pair with new information.</p> AsyncSync <pre><code>import time\nfrom dataclasses import replace\n\n# Option 1: Update with a new pair object\nupdated_pair = replace(\n    complete_pair,\n    meta=replace(complete_pair.meta, created_at=time.time())\n)\nresult = await storage.update_pair(complete_pair.id, updated_pair)\n\n# Option 2: Update using a callable\ndef update_cache_key(pair):\n    return replace(pair, cache_key=b\"new_key\")\n\nresult = await storage.update_pair(complete_pair.id, update_cache_key)\n\nif result is None:\n    print(\"Pair not found or is incomplete\")\n</code></pre> <pre><code>from dataclasses import replace\n\n# Option 1: Update with a new pair object\nupdated_pair = replace(\n    complete_pair,\n    response=replace(complete_pair.response, status_code=304)\n)\nresult = storage.update_pair(complete_pair.id, updated_pair)\n\n# Option 2: Update using a callable\ndef update_cache_key(pair):\n    return replace(pair, cache_key=b\"new_key\")\n\nresult = storage.update_pair(complete_pair.id, update_cache_key)\n\nif result is None:\n    print(\"Pair not found or is incomplete\")\n</code></pre>"},{"location":"beta/storages/#removing-pairs","title":"Removing Pairs","text":"<p>Remove pairs from the cache (soft deletion - marked as deleted but not immediately removed).</p> AsyncSync <pre><code># Soft delete a pair\nawait storage.remove(pair_id=complete_pair.id)\n\n# The pair is marked as deleted and will be removed during cleanup\n</code></pre> <pre><code># Soft delete a pair\nstorage.remove(pair_id=complete_pair.id)\n\n# The pair is marked as deleted and will be removed during cleanup\n</code></pre>"},{"location":"beta/storages/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing the full lifecycle of cache storage:</p> AsyncSync <pre><code>import uuid\nfrom hishel.beta import AsyncSqliteStorage, Request, Response, Headers\nfrom hishel._utils import make_async_iterator\n\n# Initialize storage\nstorage = AsyncSqliteStorage(\n    database_path=\"my_app_cache.db\",\n    default_ttl=3600.0  # 1 hour\n)\n\n# Create cache key\ncache_key = \"GET:https://api.example.com/users\"\n\n# Step 1: Create incomplete pair\nincomplete_pair = await storage.create_pair(\n    request=Request(\n        method=\"GET\",\n        url=\"https://api.example.com/users\",\n        stream=make_async_iterator([b\"request body\"]),\n    )\n)\n\n# Consume request stream to store it\nasync for chunk in incomplete_pair.request.aiter_stream():\n    pass  # Storage automatically saves chunks\n\n# Step 2: Add response to complete the pair\ncomplete_pair = await storage.add_response(\n    pair_id=incomplete_pair.id,\n    response=Response(\n        status_code=200,\n        headers=Headers({\"Content-Type\": \"application/json\"}),\n        stream=make_async_iterator([\n            b'{\"users\": [',\n            b'{\"id\": 1, \"name\": \"Alice\"},',\n            b'{\"id\": 2, \"name\": \"Bob\"}',\n            b']}',\n        ]),\n    ),\n    key=cache_key,\n)\n\n# Consume response stream to store it\nasync for chunk in complete_pair.response.aiter_stream():\n    pass  # Storage automatically saves chunks\n\n# Step 3: Retrieve cached pairs\ncached_pairs = await storage.get_pairs(cache_key)\n\nprint(f\"Found {len(cached_pairs)} cached pair(s)\")\n\nfor pair in cached_pairs:\n    print(f\"Request: {pair.request.method} {pair.request.url}\")\n    print(f\"Response: {pair.response.status_code}\")\n\n    # Read response body\n    body_chunks = []\n    async for chunk in pair.response.aiter_stream():\n        body_chunks.append(chunk)\n    body = b\"\".join(body_chunks)\n    print(f\"Body: {body.decode()}\")\n\n# Step 4: Update pair if needed\nfrom dataclasses import replace\n\nupdated_pair = replace(\n    complete_pair,\n    cache_key=b\"updated_key\"\n)\nawait storage.update_pair(complete_pair.id, updated_pair)\n\n# Step 5: Remove pair when no longer needed\nawait storage.remove(complete_pair.id)\n</code></pre> <pre><code>import uuid\nfrom hishel.beta import SyncSqliteStorage, Request, Response, Headers\nfrom hishel._utils import make_iterator\n\n# Initialize storage\nstorage = SyncSqliteStorage(\n    database_path=\"my_app_cache.db\",\n    default_ttl=3600.0  # 1 hour\n)\n\n# Create cache key\ncache_key = \"GET:https://api.example.com/users\"\n\n# Step 1: Create incomplete pair\nincomplete_pair = storage.create_pair(\n    request=Request(\n        method=\"GET\",\n        url=\"https://api.example.com/users\",\n        stream=make_iterator([b\"request body\"]),\n    )\n)\n\n# Consume request stream to store it\nfor chunk in incomplete_pair.request.iter_stream():\n    pass  # Storage automatically saves chunks\n\n# Step 2: Add response to complete the pair\ncomplete_pair = storage.add_response(\n    pair_id=incomplete_pair.id,\n    response=Response(\n        status_code=200,\n        headers=Headers({\"Content-Type\": \"application/json\"}),\n        stream=make_iterator([\n            b'{\"users\": [',\n            b'{\"id\": 1, \"name\": \"Alice\"},',\n            b'{\"id\": 2, \"name\": \"Bob\"}',\n            b']}',\n        ]),\n    ),\n    key=cache_key,\n)\n\n# Consume response stream to store it\nfor chunk in complete_pair.response.iter_stream():\n    pass  # Storage automatically saves chunks\n\n# Step 3: Retrieve cached pairs\ncached_pairs = storage.get_pairs(cache_key)\n\nprint(f\"Found {len(cached_pairs)} cached pair(s)\")\n\nfor pair in cached_pairs:\n    print(f\"Request: {pair.request.method} {pair.request.url}\")\n    print(f\"Response: {pair.response.status_code}\")\n\n    # Read response body\n    body_chunks = []\n    for chunk in pair.response.iter_stream():\n        body_chunks.append(chunk)\n    body = b\"\".join(body_chunks)\n    print(f\"Body: {body.decode()}\")\n\n# Step 4: Update pair if needed\nfrom dataclasses import replace\n\nupdated_pair = replace(\n    complete_pair,\n    cache_key=b\"updated_key\"\n)\nstorage.update_pair(complete_pair.id, updated_pair)\n\n# Step 5: Remove pair when no longer needed\nstorage.remove(complete_pair.id)\n</code></pre>"},{"location":"beta/storages/#advanced-topics","title":"Advanced Topics","text":""},{"location":"beta/storages/#stream-handling","title":"Stream Handling","text":"<p>Hishel storages efficiently handle large request and response bodies using streams. Streams are automatically chunked and stored as you consume them.</p> <p>Important: You must consume streams (iterate through them) for the data to be stored. Simply creating a pair with a stream doesn't store the stream data.</p> AsyncSync <pre><code># Create pair with streaming body\nincomplete_pair = await storage.create_pair(\n    request=Request(\n        method=\"POST\",\n        url=\"https://api.example.com/upload\",\n        stream=make_async_iterator([\n            b\"chunk1\",\n            b\"chunk2\",\n            b\"chunk3\",\n        ])\n    )\n)\n\n# IMPORTANT: Consume the stream to store it\nasync for chunk in incomplete_pair.request.aiter_stream():\n    # Each chunk is stored as you iterate\n    pass\n\n# Now the request stream is fully stored\n# You can retrieve it later:\npairs = await storage.get_pairs(cache_key)\nasync for chunk in pairs[0].request.aiter_stream():\n    print(f\"Chunk: {chunk}\")\n</code></pre> <pre><code># Create pair with streaming body\nincomplete_pair = storage.create_pair(\n    request=Request(\n        method=\"POST\",\n        url=\"https://api.example.com/upload\",\n        stream=make_iterator([\n            b\"chunk1\",\n            b\"chunk2\",\n            b\"chunk3\",\n        ])\n    )\n)\n\n# IMPORTANT: Consume the stream to store it\nfor chunk in incomplete_pair.request.iter_stream():\n    # Each chunk is stored as you iterate\n    pass\n\n# Now the request stream is fully stored\n# You can retrieve it later:\npairs = storage.get_pairs(cache_key)\nfor chunk in pairs[0].request.iter_stream():\n    print(f\"Chunk: {chunk}\")\n</code></pre>"},{"location":"beta/storages/#ttl-and-expiration","title":"TTL and Expiration","text":"<p>Control how long cached entries remain valid:</p> AsyncSync <pre><code># Set default TTL for all entries\nstorage = AsyncSqliteStorage(default_ttl=3600.0)  # 1 hour\n\n# Override TTL for specific requests using metadata\nincomplete_pair = await storage.create_pair(\n    request=Request(\n        method=\"GET\",\n        url=\"https://api.example.com/data\",\n        metadata={\"hishel_ttl\": 7200.0}  # 2 hours for this entry\n    )\n)\n\n# Disable TTL refresh on access\nstorage = AsyncSqliteStorage(\n    default_ttl=3600.0,\n    refresh_ttl_on_access=False  # TTL won't reset when accessed\n)\n</code></pre> <pre><code># Set default TTL for all entries\nstorage = SyncSqliteStorage(default_ttl=3600.0)  # 1 hour\n\n# Override TTL for specific requests using metadata\nincomplete_pair = storage.create_pair(\n    request=Request(\n        method=\"GET\",\n        url=\"https://api.example.com/data\",\n        metadata={\"hishel_ttl\": 7200.0}  # 2 hours for this entry\n    )\n)\n\n# Disable TTL refresh on access\nstorage = SyncSqliteStorage(\n    default_ttl=3600.0,\n    refresh_ttl_on_access=False  # TTL won't reset when accessed\n)\n</code></pre>"},{"location":"beta/storages/#cleanup-and-maintenance","title":"Cleanup and Maintenance","text":"<p>Storage automatically performs cleanup operations to remove expired and deleted entries. Cleanup runs periodically when storage operations are performed.</p> <p>Cleanup removes:</p> <ul> <li>Expired entries (past their TTL)</li> <li>Entries marked as deleted for more than 7 days</li> <li>Incomplete pairs older than 1 hour (considered corrupted)</li> <li>Pairs with missing or incomplete streams</li> </ul> <p>The cleanup process is automatic and doesn't require manual intervention.</p>"},{"location":"beta/storages/#custom-pair-ids","title":"Custom Pair IDs","text":"<p>By default, pair IDs are auto-generated UUIDs. You can provide custom IDs if needed:</p> AsyncSync <pre><code>import uuid\n\n# Provide custom UUID\ncustom_id = uuid.uuid4()\nincomplete_pair = await storage.create_pair(\n    request=Request(method=\"GET\", url=\"https://api.example.com\"),\n    id=custom_id\n)\n\nassert incomplete_pair.id == custom_id\n</code></pre> <pre><code>import uuid\n\n# Provide custom UUID\ncustom_id = uuid.uuid4()\nincomplete_pair = storage.create_pair(\n    request=Request(method=\"GET\", url=\"https://api.example.com\"),\n    id=custom_id\n)\n\nassert incomplete_pair.id == custom_id\n</code></pre>"},{"location":"beta/storages/#database-schema","title":"Database Schema","text":"<p>For reference, here's the SQLite database schema used by the storage:</p>"},{"location":"beta/storages/#entries-table","title":"<code>entries</code> Table","text":"<p>Stores request-response pair metadata.</p> Column Type Description <code>id</code> BLOB Primary key - UUID of the pair <code>cache_key</code> BLOB Cache key for grouping pairs (NULL for incomplete pairs) <code>data</code> BLOB Serialized pair data (request, response, metadata) <code>created_at</code> REAL Timestamp when the pair was created <code>deleted_at</code> REAL Timestamp when soft deleted (NULL if not deleted) <p>Indexes: - <code>idx_entries_cache_key</code> - Fast lookups by cache key - <code>idx_entries_deleted_at</code> - Efficient cleanup queries</p>"},{"location":"beta/storages/#streams-table","title":"<code>streams</code> Table","text":"<p>Stores request and response body chunks.</p> Column Type Description <code>entry_id</code> BLOB Foreign key to entries.id <code>kind</code> INTEGER Stream type: 0 = request, 1 = response <code>chunk_number</code> INTEGER Chunk sequence number (0, 1, 2, ... or -1 for completion marker) <code>chunk_data</code> BLOB The actual chunk data <p>Primary Key: <code>(entry_id, kind, chunk_number)</code></p> <p>Special Values: - <code>chunk_number = -1</code> - Completion marker (empty data, signals end of stream) - <code>kind = 0</code> - Request stream - <code>kind = 1</code> - Response stream</p>"},{"location":"beta/storages/#integration-with-state-machine","title":"Integration with State Machine","text":"<p>Storage is designed to work seamlessly with Hishel's RFC 9111 state machine. Here's how they integrate:</p> AsyncSync <pre><code>from hishel.beta import (\n    create_idle_state,\n    CacheMiss,\n    FromCache,\n    StoreAndUse,\n    AsyncSqliteStorage,\n    Request,\n)\n\nstorage = AsyncSqliteStorage()\n\n# Get cache key for request\ncache_key = \"GET:https://api.example.com/users\"\n\n# Retrieve cached pairs\ncached_pairs = await storage.get_pairs(cache_key)\n\n# Start state machine\nstate = create_idle_state(\"client\")\nrequest = Request(method=\"GET\", url=\"https://api.example.com/users\")\n\n# Transition based on cached pairs\nnext_state = state.next(request, cached_pairs)\n\nif isinstance(next_state, FromCache):\n    # Use cached response\n    response = next_state.pair.response\n\nelif isinstance(next_state, CacheMiss):\n    # Fetch from origin and store\n    origin_response = ...  # fetch from server\n\n    # Create pair in storage\n    incomplete_pair = await storage.create_pair(request)\n    async for _ in incomplete_pair.request.aiter_stream():\n        pass\n\n    # Evaluate if we should store it\n    storage_state = next_state.next(origin_response, incomplete_pair.id)\n\n    if isinstance(storage_state, StoreAndUse):\n        # Add response to storage\n        complete_pair = await storage.add_response(\n            pair_id=incomplete_pair.id,\n            response=origin_response,\n            key=cache_key,\n        )\n        async for _ in complete_pair.response.aiter_stream():\n            pass\n\n    response = origin_response\n</code></pre> <pre><code>from hishel.beta import (\n    create_idle_state,\n    CacheMiss,\n    FromCache,\n    StoreAndUse,\n    SyncSqliteStorage,\n    Request,\n)\n\nstorage = SyncSqliteStorage()\n\n# Get cache key for request\ncache_key = \"GET:https://api.example.com/users\"\n\n# Retrieve cached pairs\ncached_pairs = storage.get_pairs(cache_key)\n\n# Start state machine\nstate = create_idle_state(\"client\")\nrequest = Request(method=\"GET\", url=\"https://api.example.com/users\")\n\n# Transition based on cached pairs\nnext_state = state.next(request, cached_pairs)\n\nif isinstance(next_state, FromCache):\n    # Use cached response\n    response = next_state.pair.response\n\nelif isinstance(next_state, CacheMiss):\n    # Fetch from origin and store\n    origin_response = ...  # fetch from server\n\n    # Create pair in storage\n    incomplete_pair = storage.create_pair(request)\n    for _ in incomplete_pair.request.iter_stream():\n        pass\n\n    # Evaluate if we should store it\n    storage_state = next_state.next(origin_response, incomplete_pair.id)\n\n    if isinstance(storage_state, StoreAndUse):\n        # Add response to storage\n        complete_pair = storage.add_response(\n            pair_id=incomplete_pair.id,\n            response=origin_response,\n            key=cache_key,\n        )\n        for _ in complete_pair.response.iter_stream():\n            pass\n\n    response = origin_response\n</code></pre>"},{"location":"beta/integrations/httpx/","title":"HTTPX Integration","text":"<p>Hishel provides seamless integration with HTTPX, adding RFC 9111-compliant HTTP caching to your HTTPX applications with minimal code changes.</p>"},{"location":"beta/integrations/httpx/#quick-start","title":"Quick Start","text":"<p>The easiest way to add caching to your HTTPX application is using the cache-enabled client classes:</p> SyncAsync <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# First request - fetches from origin\nresponse = client.get(\"https://api.example.com/data\")\nprint(response.extensions[\"hishel_from_cache\"])  # False\n\n# Second request - served from cache\nresponse = client.get(\"https://api.example.com/data\")\nprint(response.extensions[\"hishel_from_cache\"])  # True\n</code></pre> <pre><code>from hishel.beta.httpx import AsyncCacheClient\n\nasync with AsyncCacheClient() as client:\n    # First request - fetches from origin\n    response = await client.get(\"https://api.example.com/data\")\n    print(response.extensions[\"hishel_from_cache\"])  # False\n\n    # Second request - served from cache\n    response = await client.get(\"https://api.example.com/data\")\n    print(response.extensions[\"hishel_from_cache\"])  # True\n</code></pre> <p>That's it! Hishel automatically caches responses according to RFC 9111 rules.</p>"},{"location":"beta/integrations/httpx/#cache-clients","title":"Cache Clients","text":"<p>Hishel provides drop-in replacements for HTTPX's <code>Client</code> and <code>AsyncClient</code>:</p> <ul> <li><code>SyncCacheClient</code> - Synchronous caching client</li> <li><code>AsyncCacheClient</code> - Asynchronous caching client</li> </ul> <p>These clients inherit from HTTPX clients and accept all the same parameters, plus additional caching configuration.</p>"},{"location":"beta/integrations/httpx/#basic-usage","title":"Basic Usage","text":"SyncAsync <pre><code>from hishel.beta.httpx import SyncCacheClient\n\n# Create client with default settings\nclient = SyncCacheClient()\n\n# Make requests as usual\nresponse = client.get(\"https://api.example.com/users\")\n\n# All HTTPX methods work\nclient.post(\"https://api.example.com/data\", json={\"key\": \"value\"})\nclient.put(\"https://api.example.com/resource/1\", data=\"content\")\n\n# Don't forget to close\nclient.close()\n\n# Or use context manager\nwith SyncCacheClient() as client:\n    response = client.get(\"https://api.example.com/data\")\n</code></pre> <pre><code>from hishel.beta.httpx import AsyncCacheClient\n\n# Create client with default settings\nclient = AsyncCacheClient()\n\n# Make requests as usual\nresponse = await client.get(\"https://api.example.com/users\")\n\n# All HTTPX async methods work\nawait client.post(\"https://api.example.com/data\", json={\"key\": \"value\"})\nawait client.put(\"https://api.example.com/resource/1\", data=\"content\")\n\n# Don't forget to close\nawait client.aclose()\n\n# Or use context manager (recommended)\nasync with AsyncCacheClient() as client:\n    response = await client.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"beta/integrations/httpx/#configuration","title":"Configuration","text":"<p>Configure storage backend and cache behavior:</p> SyncAsync <pre><code>from hishel.beta import CacheOptions, SyncSqliteStorage\nfrom hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient(\n    # Storage configuration\n    storage=SyncSqliteStorage(\n        database_path=\"my_cache.db\",\n        default_ttl=3600,  # 1 hour default TTL\n        refresh_ttl_on_access=True\n    ),\n\n    # Cache behavior options\n    cache_options=CacheOptions(\n        shared=False,  # Private cache\n        supported_methods=[\"GET\", \"HEAD\"],\n        allow_stale=False\n    )\n)\n</code></pre> <pre><code>from hishel.beta import CacheOptions, AsyncSqliteStorage\nfrom hishel.beta.httpx import AsyncCacheClient\n\nclient = AsyncCacheClient(\n    # Storage configuration\n    storage=AsyncSqliteStorage(\n        database_path=\"my_cache.db\",\n        default_ttl=3600,  # 1 hour default TTL\n        refresh_ttl_on_access=True\n    ),\n\n    # Cache behavior options\n    cache_options=CacheOptions(\n        shared=False,  # Private cache\n        supported_methods=[\"GET\", \"HEAD\"],\n        allow_stale=False\n    )\n)\n</code></pre> <p>Configuration Options:</p> Option Type Default Description <code>storage</code> <code>Storage</code> <code>None</code> (in-memory) Storage backend for cached data <code>cache_options</code> <code>CacheOptions</code> <code>None</code> (defaults) RFC 9111 caching behavior configuration"},{"location":"beta/integrations/httpx/#cache-transports","title":"Cache Transports","text":"<p>For more control or to integrate with existing HTTPX clients, use cache transports directly:</p> SyncAsync <pre><code>import httpx\nfrom hishel.beta import SyncSqliteStorage, CacheOptions\nfrom hishel.beta.httpx import SyncCacheTransport\n\n# Create transport with caching\ntransport = SyncCacheTransport(\n    next_transport=httpx.HTTPTransport(),\n    storage=SyncSqliteStorage(),\n    cache_options=CacheOptions()\n)\n\n# Use with standard HTTPX client\nclient = httpx.Client(transport=transport)\n\nresponse = client.get(\"https://api.example.com/data\")\n</code></pre> <pre><code>import httpx\nfrom hishel.beta import AsyncSqliteStorage, CacheOptions\nfrom hishel.beta.httpx import AsyncCacheTransport\n\n# Create transport with caching\ntransport = AsyncCacheTransport(\n    next_transport=httpx.AsyncHTTPTransport(),\n    storage=AsyncSqliteStorage(),\n    cache_options=CacheOptions()\n)\n\n# Use with standard HTTPX client\nclient = httpx.AsyncClient(transport=transport)\n\nresponse = await client.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"beta/integrations/httpx/#when-to-use-transports","title":"When to Use Transports","text":"<p>Use transports when you need to: - Combine with other custom transports - Add caching to existing HTTPX clients - Have fine-grained control over transport layer - Build custom client classes</p>"},{"location":"beta/integrations/httpx/#chaining-transports","title":"Chaining Transports","text":"SyncAsync <pre><code>import httpx\nfrom hishel.beta.httpx import SyncCacheTransport\nfrom hishel.beta import SyncSqliteStorage\n\n# Custom transport (e.g., for logging)\nclass LoggingTransport(httpx.BaseTransport):\n    def __init__(self, transport: httpx.BaseTransport):\n        self.transport = transport\n\n    def handle_request(self, request: httpx.Request) -&gt; httpx.Response:\n        print(f\"Request: {request.method} {request.url}\")\n        response = self.transport.handle_request(request)\n        print(f\"Response: {response.status_code}\")\n        return response\n\n# Chain: HTTP -&gt; Cache -&gt; Logging\ntransport = LoggingTransport(\n    transport=SyncCacheTransport(\n        next_transport=httpx.HTTPTransport(),\n        storage=SyncSqliteStorage()\n    )\n)\n\nclient = httpx.Client(transport=transport)\n</code></pre> <pre><code>import httpx\nfrom hishel.beta.httpx import AsyncCacheTransport\nfrom hishel.beta import AsyncSqliteStorage\n\n# Custom transport (e.g., for logging)\nclass LoggingTransport(httpx.AsyncBaseTransport):\n    def __init__(self, transport: httpx.AsyncBaseTransport):\n        self.transport = transport\n\n    async def handle_async_request(\n        self, request: httpx.Request\n    ) -&gt; httpx.Response:\n        print(f\"Request: {request.method} {request.url}\")\n        response = await self.transport.handle_async_request(request)\n        print(f\"Response: {response.status_code}\")\n        return response\n\n# Chain: HTTP -&gt; Cache -&gt; Logging\ntransport = LoggingTransport(\n    transport=AsyncCacheTransport(\n        next_transport=httpx.AsyncHTTPTransport(),\n        storage=AsyncSqliteStorage()\n    )\n)\n\nclient = httpx.AsyncClient(transport=transport)\n</code></pre>"},{"location":"beta/integrations/httpx/#controlling-cache-behavior","title":"Controlling Cache Behavior","text":""},{"location":"beta/integrations/httpx/#using-extensions-recommended","title":"Using Extensions (Recommended)","text":"<p>Set caching metadata using HTTPX's <code>extensions</code> parameter:</p> SyncAsync <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\n# Custom TTL for specific request\nresponse = client.get(\n    \"https://api.example.com/data\",\n    extensions={\"hishel_ttl\": 300}  # Cache for 5 minutes\n)\n\n# Ignore caching rules\nresponse = client.get(\n    \"https://api.example.com/private\",\n    extensions={\"hishel_spec_ignore\": True}\n)\n\n# Multiple options\nresponse = client.get(\n    \"https://api.example.com/search\",\n    extensions={\n        \"hishel_ttl\": 600,\n        \"hishel_refresh_ttl_on_access\": True,\n        \"hishel_body_key\": True  # Include body in cache key\n    }\n)\n</code></pre> <pre><code>from hishel.beta.httpx import AsyncCacheClient\n\nasync with AsyncCacheClient() as client:\n    # Custom TTL for specific request\n    response = await client.get(\n        \"https://api.example.com/data\",\n        extensions={\"hishel_ttl\": 300}  # Cache for 5 minutes\n    )\n\n    # Ignore caching rules\n    response = await client.get(\n        \"https://api.example.com/private\",\n        extensions={\"hishel_spec_ignore\": True}\n    )\n\n    # Multiple options\n    response = await client.get(\n        \"https://api.example.com/search\",\n        extensions={\n            \"hishel_ttl\": 600,\n            \"hishel_refresh_ttl_on_access\": True,\n            \"hishel_body_key\": True  # Include body in cache key\n        }\n    )\n</code></pre>"},{"location":"beta/integrations/httpx/#using-headers-alternative","title":"Using Headers (Alternative)","text":"<p>You can also use HTTP headers:</p> SyncAsync <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\nresponse = client.get(\n    \"https://api.example.com/data\",\n    headers={\"X-Hishel-Ttl\": \"300\"}\n)\n</code></pre> <pre><code>from hishel.beta.httpx import AsyncCacheClient\n\nasync with AsyncCacheClient() as client:\n    response = await client.get(\n        \"https://api.example.com/data\",\n        headers={\"X-Hishel-Ttl\": \"300\"}\n    )\n</code></pre> <p>Extensions vs Headers</p> <p>Use <code>extensions</code> for better type safety and to avoid sending cache control headers to the server.</p>"},{"location":"beta/integrations/httpx/#available-metadata","title":"Available Metadata","text":"<p>See Metadata Documentation for complete reference:</p> <ul> <li><code>hishel_ttl</code> - Custom TTL in seconds</li> <li><code>hishel_refresh_ttl_on_access</code> - Enable sliding expiration</li> <li><code>hishel_spec_ignore</code> - Ignore RFC 9111 rules</li> <li><code>hishel_body_key</code> - Include body in cache key (for POST/GraphQL)</li> </ul>"},{"location":"beta/integrations/httpx/#inspecting-cache-status","title":"Inspecting Cache Status","text":"<p>Check if responses came from cache using metadata:</p> SyncAsync <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()\n\nresponse = client.get(\"https://api.example.com/data\")\n\n# Check cache status\nfrom_cache = response.extensions.get(\"hishel_from_cache\", False)\nrevalidated = response.extensions.get(\"hishel_revalidated\", False)\nstored = response.extensions.get(\"hishel_stored\", False)\n\nif from_cache and not revalidated:\n    print(\"\u2713 Fresh cache hit\")\nelif from_cache and revalidated:\n    print(\"\u21bb Revalidated (304)\")\nelse:\n    print(\"\u2717 Cache miss\")\n\nif stored:\n    print(\"Response was cached for future requests\")\n</code></pre> <pre><code>from hishel.beta.httpx import AsyncCacheClient\n\nasync with AsyncCacheClient() as client:\n    response = await client.get(\"https://api.example.com/data\")\n\n    # Check cache status\n    from_cache = response.extensions.get(\"hishel_from_cache\", False)\n    revalidated = response.extensions.get(\"hishel_revalidated\", False)\n    stored = response.extensions.get(\"hishel_stored\", False)\n\n    if from_cache and not revalidated:\n        print(\"\u2713 Fresh cache hit\")\n    elif from_cache and revalidated:\n        print(\"\u21bb Revalidated (304)\")\n    else:\n        print(\"\u2717 Cache miss\")\n\n    if stored:\n        print(\"Response was cached for future requests\")\n</code></pre>"},{"location":"beta/integrations/httpx/#migration-from-standard-httpx","title":"Migration from Standard HTTPX","text":"<p>Migrating existing HTTPX code to use Hishel is straightforward:</p> <p>Before (Standard HTTPX): <pre><code>import httpx\n\nclient = httpx.Client()\nresponse = client.get(\"https://api.example.com/data\")\n</code></pre></p> <p>After (With Caching): <pre><code>from hishel.beta.httpx import SyncCacheClient\n\nclient = SyncCacheClient()  # Drop-in replacement\nresponse = client.get(\"https://api.example.com/data\")\n</code></pre></p> <p>All HTTPX features continue to work:</p> <ul> <li>\u2713 Request parameters (<code>params</code>, <code>headers</code>, <code>json</code>, <code>data</code>)</li> <li>\u2713 Authentication (<code>auth</code>)</li> <li>\u2713 Timeouts (<code>timeout</code>)</li> <li>\u2713 HTTP/2 support (<code>http2=True</code>)</li> <li>\u2713 Proxies (<code>proxies</code>)</li> <li>\u2713 Custom transports</li> <li>\u2713 Event hooks</li> <li>\u2713 Connection pooling</li> </ul>"},{"location":"beta/integrations/httpx/#see-also","title":"See Also","text":"<ul> <li>Metadata Reference - Complete guide to caching metadata</li> <li>Storage Documentation - Storage backend configuration</li> <li>Specification - RFC 9111 state machine</li> <li>HTTPX Documentation - Official HTTPX docs</li> </ul>"},{"location":"beta/integrations/requests/","title":"Requests Integration","text":"<p>Hishel provides seamless integration with Requests, adding RFC 9111-compliant HTTP caching to your Requests applications with minimal code changes.</p>"},{"location":"beta/integrations/requests/#quick-start","title":"Quick Start","text":"<p>Add caching to your Requests application using the <code>CacheAdapter</code>:</p> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\n# Create session with cache adapter\nsession = requests.Session()\nsession.mount(\"https://\", CacheAdapter())\nsession.mount(\"http://\", CacheAdapter())\n\n# First request - fetches from origin\nresponse = session.get(\"https://api.example.com/data\")\nprint(response.headers.get(\"X-Hishel-From-Cache\"))  # None\n\n# Second request - served from cache\nresponse = session.get(\"https://api.example.com/data\")\nprint(response.headers.get(\"X-Hishel-From-Cache\"))  # True\n</code></pre> <p>That's it! Hishel automatically caches responses according to RFC 9111 rules.</p>"},{"location":"beta/integrations/requests/#cache-adapter","title":"Cache Adapter","text":"<p>Hishel provides <code>CacheAdapter</code>, a custom HTTPAdapter that adds caching to Requests sessions.</p>"},{"location":"beta/integrations/requests/#basic-usage","title":"Basic Usage","text":"<pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\n# Create a session\nsession = requests.Session()\n\n# Mount cache adapter for HTTP and HTTPS\nadapter = CacheAdapter()\nsession.mount(\"https://\", adapter)\nsession.mount(\"http://\", adapter)\n\n# Make requests as usual\nresponse = session.get(\"https://api.example.com/users\")\n\n# All requests methods work\nsession.post(\"https://api.example.com/data\", json={\"key\": \"value\"})\nsession.put(\"https://api.example.com/resource/1\", data=\"content\")\n\n# Close when done\nsession.close()\n</code></pre> <p>Using Context Manager:</p> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nwith requests.Session() as session:\n    session.mount(\"https://\", CacheAdapter())\n    session.mount(\"http://\", CacheAdapter())\n\n    response = session.get(\"https://api.example.com/data\")\n    print(response.json())\n</code></pre>"},{"location":"beta/integrations/requests/#configuration","title":"Configuration","text":"<p>Configure storage backend and cache behavior:</p> <pre><code>import requests\nfrom hishel.beta import CacheOptions, SyncSqliteStorage\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\n\nadapter = CacheAdapter(\n    # Storage configuration\n    storage=SyncSqliteStorage(\n        database_path=\"my_cache.db\",\n        default_ttl=3600,  # 1 hour default TTL\n        refresh_ttl_on_access=True\n    ),\n\n    # Cache behavior options\n    cache_options=CacheOptions(\n        shared=False,  # Private cache\n        supported_methods=[\"GET\", \"HEAD\"],\n        allow_stale=False\n    )\n)\n\nsession.mount(\"https://\", adapter)\nsession.mount(\"http://\", adapter)\n</code></pre> <p>Configuration Options:</p> Option Type Default Description <code>storage</code> <code>SyncBaseStorage</code> <code>None</code> (in-memory) Storage backend for cached data <code>cache_options</code> <code>CacheOptions</code> <code>None</code> (defaults) RFC 9111 caching behavior configuration <code>pool_connections</code> <code>int</code> <code>10</code> Number of connection pools to cache <code>pool_maxsize</code> <code>int</code> <code>10</code> Max number of connections in pool <code>max_retries</code> <code>int</code> <code>0</code> Max retries for requests <code>pool_block</code> <code>bool</code> <code>False</code> Block when no free connections"},{"location":"beta/integrations/requests/#controlling-cache-behavior","title":"Controlling Cache Behavior","text":""},{"location":"beta/integrations/requests/#using-headers","title":"Using Headers","text":"<p>Set caching metadata using HTTP headers:</p> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"https://\", CacheAdapter())\n\n# Custom TTL for specific request\nresponse = session.get(\n    \"https://api.example.com/data\",\n    headers={\"X-Hishel-Ttl\": \"300\"}  # Cache for 5 minutes\n)\n\n# Ignore caching rules\nresponse = session.get(\n    \"https://api.example.com/private\",\n    headers={\"X-Hishel-Spec-Ignore\": \"true\"}\n)\n\n# Multiple options\nresponse = session.get(\n    \"https://api.example.com/search\",\n    headers={\n        \"X-Hishel-Ttl\": \"600\",\n        \"X-Hishel-Refresh-Ttl-On-Access\": \"true\",\n        \"X-Hishel-Body-Key\": \"true\"  # Include body in cache key\n    }\n)\n</code></pre>"},{"location":"beta/integrations/requests/#available-metadata","title":"Available Metadata","text":"<p>See Metadata Documentation for complete reference:</p> <ul> <li><code>X-Hishel-Ttl</code> - Custom TTL in seconds</li> <li><code>X-Hishel-Refresh-Ttl-On-Access</code> - Enable sliding expiration</li> <li><code>X-Hishel-Spec-Ignore</code> - Ignore RFC 9111 rules</li> <li><code>X-Hishel-Body-Key</code> - Include body in cache key (for POST/GraphQL)</li> </ul>"},{"location":"beta/integrations/requests/#inspecting-cache-status","title":"Inspecting Cache Status","text":"<p>Check if responses came from cache using response headers:</p> <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"https://\", CacheAdapter())\n\nresponse = session.get(\"https://api.example.com/data\")\n\n# Check cache status\nfrom_cache = response.headers.get(\"X-Hishel-From-Cache\") == \"True\"\nrevalidated = response.headers.get(\"X-Hishel-Revalidated\") == \"True\"\nstored = response.headers.get(\"X-Hishel-Stored\") == \"True\"\n\nif from_cache and not revalidated:\n    print(\"\u2713 Fresh cache hit\")\nelif from_cache and revalidated:\n    print(\"\u21bb Revalidated (304)\")\nelse:\n    print(\"\u2717 Cache miss\")\n\nif stored:\n    print(\"Response was cached for future requests\")\n</code></pre>"},{"location":"beta/integrations/requests/#migration-from-standard-requests","title":"Migration from Standard Requests","text":"<p>Migrating existing Requests code to use Hishel is straightforward:</p> <p>Before (Standard Requests): <pre><code>import requests\n\nsession = requests.Session()\nresponse = session.get(\"https://api.example.com/data\")\n</code></pre></p> <p>After (With Caching): <pre><code>import requests\nfrom hishel.beta.requests import CacheAdapter\n\nsession = requests.Session()\nsession.mount(\"https://\", CacheAdapter())  # Add this line\nsession.mount(\"http://\", CacheAdapter())   # Add this line\nresponse = session.get(\"https://api.example.com/data\")\n</code></pre></p> <p>All Requests features continue to work:</p> <ul> <li>\u2713 Request parameters (<code>params</code>, <code>headers</code>, <code>json</code>, <code>data</code>)</li> <li>\u2713 Authentication (<code>auth</code>)</li> <li>\u2713 Timeouts (<code>timeout</code>)</li> <li>\u2713 Proxies (<code>proxies</code>)</li> <li>\u2713 SSL verification (<code>verify</code>)</li> <li>\u2713 Cookies</li> <li>\u2713 Redirects</li> <li>\u2713 Sessions</li> </ul>"},{"location":"beta/integrations/requests/#see-also","title":"See Also","text":"<ul> <li>Metadata Reference - Complete guide to caching metadata</li> <li>Storage Documentation - Storage backend configuration</li> <li>Specification - RFC 9111 state machine</li> <li>HTTPX Integration - Alternative async HTTP client</li> <li>Requests Documentation - Official Requests docs</li> </ul>"},{"location":"examples/fastapi/","title":"FastAPI","text":"<p>Many <code>FastAPI</code> users use <code>HTTPX</code> as a modern and very fast HTTP client, which also supports async/await syntax like FastAPI does.</p> <p>Here is an example of how <code>HTTPX</code> can be used in <code>FastAPI</code>.</p> <pre><code>from fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom httpx import Limits\n\napp = FastAPI()\nclient = AsyncClient(limits=Limits(max_connections=1000))\n\n@app.get(\"/\")\nasync def main():\n    response = await client.get('https://www.encode.io')\n    return response.status_code\n</code></pre> <p>Now let's do some load testing using the popular load testing tool Locust.</p> <p>Here are the test results:</p> <p> </p> <p>Despite the fact that we use async/await, we got only \u00b170 RPS.</p> <p>Now let's change the <code>httpx.AsyncClient</code> to <code>hishel.AsyncCacheClient</code> and do the same tests again.</p> <pre><code>from fastapi import FastAPI\nfrom hishel import AsyncCacheClient\nfrom httpx import Limits\n\napp = FastAPI()\nclient = AsyncCacheClient(limits=Limits(max_connections=1000))\n\n@app.get(\"/\")\nasync def main():\n    response = await client.get('https://www.encode.io')\n    return response.status_code\n</code></pre> <p>Here are the test results:</p> <p> </p> <p>Now we have more than 365+ RPS using the power of HTTP caching.</p>"},{"location":"examples/flask/","title":"Flask","text":"<p>As a <code>Flask</code> user, you can use the power of <code>HTTPX</code> using its synchronous interface.</p> <p>Here is a simple example:</p> <pre><code>from flask import Flask\nfrom httpx import Client\nfrom httpx import Limits\n\napp = Flask(__name__)\nclient = Client(limits=Limits(max_connections=1000))\n\n@app.route(\"/\")\ndef main():\n    response = client.get('https://www.encode.io')\n    return str(response.status_code)\n</code></pre> <p>Now let's do some load testing using the popular load testing tool Locust.</p> <p>Here are the test results:</p> <p> </p> <p>We got only \u00b120 RPS, which is not very good.</p> <p>Now let's change the <code>httpx.Client</code> to <code>hishel.CacheClient</code> and do the same tests again.</p> <pre><code>from flask import Flask\nfrom hishel import CacheClient\nfrom httpx import Limits\n\napp = Flask(__name__)\nclient = CacheClient(limits=Limits(max_connections=1000))\n\n@app.route(\"/\")\ndef main():\n    response = client.get('https://www.encode.io')\n    return str(response.status_code)\n</code></pre> <p>Here are the test results:</p> <p> </p> <p>Now we have more than \u00b1800 RPS using the power of HTTP caching.</p>"},{"location":"examples/github/","title":"GitHub","text":"<p>On this page, we'll look at why HTTP caching is important when using GitHub APIs.</p> <p>Let's create a simple program that takes the name of a <code>GitHub</code> repository and displays the stars in real time.</p> <p>To use GitHub APIs, we first need an access token. See how to create a github token here.</p> <p>However, if we write a program that makes a large number of HTTP requests to the GItHub servers, we will be blocked for a period of time because github has rate limits in place to prevent overloading their servers.</p> <p>In such cases, APIs frequently provide HTTP caching functionality, which we can use to retrieve the response from the local cache or make a new request if the data on the server has changed.</p> <p>To ensure that cached responses are not counted, we should also display the rate limit.</p> <pre><code>import os\nfrom time import sleep\n\nimport hishel\n\nTOKEN = os.getenv(\"TOKEN\")\n\nclient = hishel.CacheClient(\n    headers={\n        \"Authorization\": f\"Bearer {TOKEN}\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n        \"Accept\": \"application/vnd.github+json\",\n    },\n)\n\nrepo = input(\"Enter repo name: \")  # example: \"karpetrosyan/hishel\"\norganization, repo = repo.split(\"/\")\n\n\nwhile True:\n    stars_response = client.get(f\"https://api.github.com/repos/{organization}/{repo}\")\n    stars = stars_response.json()[\"stargazers_count\"]\n\n    rate_response = client.get(\"https://api.github.com/rate_limit\")\n    remaining = rate_response.json()[\"rate\"][\"remaining\"]\n\n    print(f\"\\rStars: {stars} Remaining rate limit: {remaining}\", end=\"\")\n    sleep(1)\n</code></pre> <p>Change <code>hishel.CacheClient</code> to <code>httpx.Client</code> to see how quickly you are wasting your rate limits!</p> <p>When <code>HTTPX</code> makes a real request in each iteration, <code>Hishel</code> consumes the rate limit only once and stores the response in the local cache.</p> <p>Also, keep in mind that when the stars count is updated, it will not be displayed immediately when using <code>Hishel</code> because it uses the cached response; instead, it will wait until the local response is considered stale before re-validating that response.</p> <p>Because <code>GitHub</code> sends a header indicating that this response has a maximum lifespan of 60 seconds, you will see the updated stars count after 60 seconds.</p> <p>Here is what that header looks like: <pre><code>Cache-Control: private, max-age=60, s-maxage=60\n</code></pre></p> <p>Anyway, if you want to see the update without any delay, you can explicitly tell the <code>Hishel</code> that you want to always re-validate the response before using it, which is also free and doesn't have a rate limit!</p> <p>Example:</p> <pre><code>client = hishel.CacheClient(\n    headers={\n        \"Authorization\": f\"Bearer {TOKEN}\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n        \"Accept\": \"application/vnd.github+json\",\n    },\n    controller=hishel.Controller(always_revalidate=True)\n)\n</code></pre>"}]}