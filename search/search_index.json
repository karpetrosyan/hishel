{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Hishel - An elegant HTTP Cache implementation for httpx and httpcore.</p> <p> </p> <p> </p> <p>Hishel (\u0570\u056b\u0577\u0565\u056c, remember) is a library that implements HTTP Caching for HTTPX and HTTP Core libraries in accordance with RFC 9111, the most recent caching specification.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Persistence: Responses are cached in the persistent memory for later use.</li> <li> Compatibility: It is completely compatible with your existing transports or connection pools, whether they are default, custom, or provided by third-party libraries.</li> <li> Easy to use: You continue to use httpx while also enabling web cache.</li> <li> Smart: Attempts to clearly implement RFC 9111, understands <code>Vary</code>, <code>Etag</code>, <code>Last-Modified</code>,  <code>Cache-Control</code>, and <code>Expires</code> headers, and handles response re-validation automatically.</li> <li> Configurable: You have complete control over how the responses are stored and serialized.</li> <li> From the package:<ul> <li>Built-in support for File system  , Redis , SQLite  , and AWS S3  backends.</li> <li>Built-in support for JSON  , YAML , and pickle serializers.</li> </ul> </li> <li> Very fast: Your requests will be even faster if there are no IO operations.</li> </ul>"},{"location":"#quickstart","title":"QuickStart","text":"<p>Install <code>Hishel</code> using pip: <pre><code>$ pip install hishel\n</code></pre></p> <p>Let's begin with an example of a httpx client.</p> <pre><code>import hishel\n\nwith hishel.CacheClient() as client:\n    client.get(\"https://hishel.com\")  # 0.4749558370003797s\n    client.get(\"https://hishel.com\")  # 0.002873589000046195s (~250x faster!)\n</code></pre> <p>or in asynchronous context</p> <pre><code>import hishel\n\nasync with hishel.AsyncCacheClient() as client:\n    await client.get(\"https://hishel.com\")\n    await client.get(\"https://hishel.com\")  # takes from the cache\n</code></pre>"},{"location":"#configurations","title":"Configurations","text":"<p>Configure when and how you want to store your responses.</p> <pre><code>import hishel\n\n# All the specification configs\ncontroller = hishel.Controller(\n        # Cache only GET and POST methods\n        cacheable_methods=[\"GET\", \"POST\"],\n\n        # Cache only 200 status codes\n        cacheable_status_codes=[200],\n\n        # Use the stale response if there is a connection issue and the new response cannot be obtained.\n        allow_stale=True,\n\n        # First, revalidate the response and then utilize it.\n        # If the response has not changed, do not download the\n        # entire response data from the server; instead,\n        # use the one you have because you know it has not been modified.\n        always_revalidate=True,\n)\n\n# All the storage configs\nstorage = hishel.S3Storage(\n        bucket_name=\"my_bucket_name\", # store my cache files in the `my_bucket_name` bucket\n        ttl=3600, # delete the response if it is in the cache for more than an hour\n)\nclient = hishel.CacheClient(controller=controller, storage=storage)\n\n\n# Ignore the fact that the server does not recommend you cache this request!\nclient.post(\n        \"https://example.com\",\n        extensions={\"force_cache\": True}\n)\n\n\n# Return a regular response if it is in the cache; else, return a 504 status code. DO NOT SEND A REQUEST!\nclient.post(\n        \"https://example.com\",\n        headers=[(\"Cache-Control\", \"only-if-cached\")]\n)\n\n\n# Ignore cached responses and do not store incoming responses!\nresponse = client.post(\n        \"https://example.com\",\n        extensions={\"cache_disabled\": True}\n)\n</code></pre>"},{"location":"#support-the-project","title":"Support the project","text":"<p>You can support the project by simply leaving a GitHub star \u2b50 or by contributing. Help us grow and continue developing good software for you \u2764\ufe0f</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for being interested in contributing to <code>Hishel</code>. We appreciate your efforts. You can contribute by reviewing the pull requests, opening an issue, or adding a new feature.</p> <p>Here I will describe the development process and the tricks that we use during the development.</p>"},{"location":"contributing/#setting-up","title":"Setting up","text":"<p>First, you should fork the Hishel so you can create your own branch and work on it.</p> <p>Then you should <code>git clone</code> your fork and create a new branch for your pull request.</p> <pre><code>git clone https://github.com/username/hishel\ncd hishel\ngit switch -c my-feature-name\n</code></pre>"},{"location":"contributing/#scripts","title":"Scripts","text":"<p><code>Hishel</code> provides a script directory to simplify the development process. Here is what each command does.</p> <ul> <li>scripts/install Set up the virtual environment and install all the necessary dependencies</li> <li>scripts/lint Runs linter, formatter, and unasync to enforce code style</li> <li>scripts/check Runs all the necessary checks, including linter, formatter, static type analyzer, and unasync checks</li> <li>scripts/test Runs <code>scripts/check</code> + <code>pytest</code> over the coverage.</li> </ul> <p>Example:</p> <pre><code>&gt;&gt;&gt; ./scripts/install\n&gt;&gt;&gt; source ./venv/bin/activate\n&gt;&gt;&gt; ./scripts/test\n+ ./scripts/check\n+ ruff format tests hishel --diff\n26 files left unchanged\n+ ruff tests hishel\n+ mypy tests hishel\nSuccess: no issues found in 38 source files\n+ python unasync.py --check\nhishel/_async/_client.py -&gt; hishel/_sync/_client.py\nhishel/_async/_pool.py -&gt; hishel/_sync/_pool.py\nhishel/_async/_transports.py -&gt; hishel/_sync/_transports.py\nhishel/_async/_mock.py -&gt; hishel/_sync/_mock.py\nhishel/_async/_storages.py -&gt; hishel/_sync/_storages.py\nhishel/_async/__init__.py -&gt; hishel/_sync/__init__.py\ntests/_async/test_storages.py -&gt; tests/_sync/test_storages.py\ntests/_async/test_transport.py -&gt; tests/_sync/test_transport.py\ntests/_async/__init__.py -&gt; tests/_sync/__init__.py\ntests/_async/test_client.py -&gt; tests/_sync/test_client.py\ntests/_async/test_pool.py -&gt; tests/_sync/test_pool.py\n+ coverage run -m pytest tests\n============================ test session starts =============================\nplatform linux -- Python 3.10.12, pytest-7.4.3, pluggy-1.3.0\nrootdir: /home/test/programs/gitprojects/hishel\nconfigfile: pyproject.toml\nplugins: anyio-4.1.0, asyncio-0.21.1\nasyncio: mode=stric`t\ncollected 158 items                                                          \n\ntests/test_controller.py ..........................................    [ 26%]\ntests/test_headers.py .....................                            [ 39%]\ntests/test_lfu_cache.py ......                                         [ 43%]\ntests/test_serializers.py .....                                        [ 46%]\ntests/test_utils.py ........                                           [ 51%]\ntests/_async/test_client.py ..                                         [ 53%]\ntests/_async/test_pool.py ..................                           [ 64%]\ntests/_async/test_storages.py ...........                              [ 71%]\ntests/_async/test_transport.py ..................                      [ 82%]\ntests/_sync/test_client.py .                                           [ 83%]\ntests/_sync/test_pool.py .........                                     [ 89%]\ntests/_sync/test_storages.py ........                                  [ 94%]\ntests/_sync/test_transport.py .........                                [100%]\n\n============================ 158 passed in 2.97s ============================= \n</code></pre> <p>Note</p> <p>Some tests may fail if you don't have all the necessary services. For example, you don't have Redis to pass the integration tests, so there is a Docker compose file in the root directory to start those services.</p>"},{"location":"contributing/#async-and-sync","title":"Async and Sync","text":"<p>Like <code>HTTP Core</code>, <code>Hishel</code> also uses the unasync strategy to support both async and sync code.</p> <p>The idea behind <code>unasync</code> is that you are writing only async code and also using some logic that converts your async code to sync code rather than writing almost the same code twice.</p> <p>In <code>Hishel</code>, there is a <code>unasync.py</code> script that converts an async directory to a sync one.</p> <p>Warning</p> <p>You should not write any code in the <code>hishel/_sync</code> directory. It is always generated by the <code>unasync.py</code> scripts, and after running CI, all your changes to that directory would be lost.</p> <p>Unasync scripts would automatically be called from <code>scripts/lint</code>, so you should just write an async code and then call <code>scripts/lint</code>.</p>"},{"location":"userguide/","title":"User Guide","text":"<p><code>Hishel</code> provides powerful tools for improving your transports.</p> <p>It analyzes your responses and saves them so they can be reused in the future.</p> <p>It is very simple to integrate with your existing application; simply change the <code>Client</code> or <code>Transport</code> class that you are using.</p>"},{"location":"userguide/#clients-and-transports","title":"Clients and Transports","text":"<p>There are three ways to make the httpx library cacheable when working with it.</p> <ul> <li>Use the class provided by <code>Hishel</code> to completely replace <code>HTTPX's Client</code>.</li> <li>Simply use your existing httpx client along with <code>Hishel's transports</code>.</li> <li>Mock the httpx classes using the <code>hishel.install_cache</code> function.</li> </ul> <p>It is always advised to use the second option because it is more reliable and adaptable.</p> <p>Warning</p> <p>Use the <code>hishel.install_cache</code> function only for experiments, and do not rely on the functionality provided by <code>hishel.install_cache</code>.</p>"},{"location":"userguide/#using-the-clients","title":"Using the Clients","text":"<p><code>Hishel</code> offers two classes for the first choice.</p> <ul> <li><code>hishel.AsyncCacheClient</code> for <code>httpx.AsyncClient</code></li> <li><code>hishel.CacheClient</code> for <code>httpx.Client</code></li> </ul> <p>This implies that you can enable HTTP caching in your existing application by simply switching to the proper Client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; \n&gt;&gt;&gt; with hishel.CacheClient() as client:\n&gt;&gt;&gt;     client.get(\"https://example.com/cachable-endpoint\")\n&gt;&gt;&gt;     response = client.get(\"https://example.com/cachable-endpoint\") # from the cache!\n</code></pre> <p>Asynchronous Example:</p> <pre><code>&gt;&gt;&gt; with hishel.AsyncCacheClient() as client:\n&gt;&gt;&gt;     await client.get(\"https://example.com/cachable-endpoint\")\n&gt;&gt;&gt;     response = await client.get(\"https://example.com/cachable-endpoint\") # from the cache!\n</code></pre> <p>Warning</p> <p>The client classes that <code>Hishel</code> offers hide the constructor signature in order to support all possible httpx versions. This means that all httpx client fields are fully valid for those clients, but because they are hidden, your IDE cannot suggest which arguments you can pass. In other words, these classes merely use *args and **kwargs and add a few arguments for cache configuration.</p> <p>This example also functions as long as the cache clients are fully compatible with the standard clients.</p> <p>Example:</p> <pre><code>client = hishel.CacheClient(\n    proxies={\n        \"all://\": \"https://myproxy.com\"\n    },\n    auth=(\"login\", \"password\"),\n    follow_redirects=True,\n    http1=False,\n    http2=True\n)\n\nclient.get(\"https://example.com\")\n</code></pre>"},{"location":"userguide/#specifying-the-client-storage","title":"Specifying the Client storage","text":"<p>Sometimes you may need to select storage rather than filesystem, and this is how you do it.</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage()\nwith hishel.CacheClient(storage=storage) as client:\n    client.get(\"https://example.com\")\n</code></pre> <p>The responses are now saved in the redis database.</p> <p>By default it will use...</p> <ul> <li>host: localhost</li> <li>port: 6379.</li> </ul> <p>Of course, you can explicitly set each configuration.</p> <p>Example:</p> <pre><code>import hishel\nimport redis\n\nstorage = hishel.RedisStorage(\n    client=redis.Redis(\n        host=\"192.168.0.85\",\n        port=8081,\n    )\n)\n\nwith hishel.CacheClient(storage=storage) as client:\n    client.get(\"https://example.com\")\n</code></pre> <p>Note</p> <p>Make sure <code>Hishel</code> has the redis extension installed if you want to use the Redis database. <pre><code>$ pip install hishel[redis]\n</code></pre></p>"},{"location":"userguide/#using-the-transports","title":"Using the Transports","text":"<p>It is always preferable to use transports that <code>Hishel</code> offers for more dependable and predictable behavior.</p> <p>We advise you to read the transports documentation if you have never used <code>HTTPX's transports</code> before continuing.</p> <p>We can divide the httpx library into two parts: the transports and the rest of the httpx library. Transports are the objects that are actually making the request.</p> <p>For synchronous and asynchronous requests, <code>Hishel</code> offers two different transports.</p> <ul> <li>CacheTransport</li> <li>AsyncCacheTransport</li> </ul> <p><code>Hishel</code> always needs a transport to work on top of it, as long as he respects the custom or third-party transports that are offered.</p> <p>Example: <pre><code>import hishel\nimport httpx\n\nwith httpx.HTTPTransport() as transport:\n    with hishel.CacheTransport(transport=transport) as cache_transport:\n        request = httpx.Request(\"GET\", \"https://example.com/cachable-endpoint\")\n        cache_transport.handle_request(request)\n        response = cache_transport.handle_request(request) # from the cache!\n</code></pre></p>"},{"location":"userguide/#using-the-transports-with-the-clients","title":"Using the Transports with the Clients","text":"<p>If you have a transport, you can provide it to clients who will use it for underlying requests.</p> <pre><code>import hishel\nimport httpx\n\ncache_transport = hishel.CacheTransport(transport=httpx.HTTPTransport())\nwith httpx.Client(transport=cache_transport) as client:\n    client.get(\"https://example.com/cachable-endpoint\")\n    response = client.get(\"https://example.com/cachable-endpoint\")  # from the cache\n</code></pre>"},{"location":"userguide/#specifying-the-transport-storage","title":"Specifying the Transport storage","text":"<p>In the same way that we can choose the storage for our clients, we can do the same for our transport.</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage()\nwith httpx.HTTPTransport() as transport:\n    with hishel.CacheTransport(transport=transport, storage=storage) as cache_transport:\n        request = httpx.Request(\"GET\", \"https://example.com/cachable-endpoint\")\n        cache_transport.handle_request(request)\n</code></pre>"},{"location":"userguide/#combining-with-the-existing-transports","title":"Combining with the existing Transports","text":"<p>Assume you already have a custom transport adapted to your business logic that you use for all requests; this is how you can add the caching layer on top of it.</p> <pre><code>import hishel\nimport httpx\nfrom my_custom_transports import MyLovelyTransport\n\ncache_transport = hishel.CacheTransport(transport=MyLovelyTransport())\nwith httpx.Client(transport=cache_transport) as client:\n    client.get(\"https://example.com/cachable-endpoint\")\n    response = client.get(\"https://example.com/cachable-endpoint\")  # from the cache\n</code></pre>"},{"location":"userguide/#using-the-connection-pool","title":"Using the Connection Pool","text":"<p><code>Hishel</code> also provides caching support for the httpcore library, which handles all of the low-level network staff for httpx.</p> <p>You may skip this section if you do not use HTTP Core.</p> <p>Example:</p> <pre><code>import hishel\nimport httpcore\n\nwith httpcore.ConnectionPool() as pool:\n    with hishel.CacheConnectionPool(pool=pool) as cache_pool:\n        cache_pool.get(\"https://example.com/cachable-endpoint\")\n        response = cache_pool.get(\"https://example.com/cachable-endpoint\") # from the cache\n</code></pre>"},{"location":"userguide/#specifying-the-connection-pool-storage","title":"Specifying the Connection Pool storage","text":"<p>In the same way that we can choose the storage for our clients and transports, we can do the same for our connection pools.</p> <pre><code>import hishel\nimport httpcore\n\nstorage = hishel.RedisStorage()\nwith httpcore.ConnectionPool() as pool:\n    with hishel.CacheConnectionPool(pool=pool, storage=storage) as cache_pool:\n        cache_pool.get(\"https://example.com/cachable-endpoint\")\n        response = cache_pool.get(\"https://example.com/cachable-endpoint\") # from the cache\n</code></pre>"},{"location":"userguide/#temporarily-disabling-the-cache","title":"Temporarily Disabling the Cache","text":"<p><code>Hishel</code> allows you to temporarily disable the cache for specific requests using the <code>cache_disabled</code> extension. Per RFC9111, the cache can effectively be disabled using the <code>Cache-Control</code> headers <code>no-store</code> (which requests that the response not be added to the cache), and <code>max-age=0</code> (which demands that any response in the cache must have 0 age - i.e. be a new request). <code>Hishel</code> respects this behavior, which can be used in two ways. First, you can specify the headers directly:</p> <pre><code>import hishel\nimport httpx\n\n# With the clients\nclient = hishel.CacheClient()\nclient.get(\n    \"https://example.com/cacheable-endpoint\",\n    headers=[(\"Cache-Control\", \"no-store\"), (\"Cache-Control\", \"max-age=0\")]\n    ) # Ignores the cache\n\n# With the transport\ncache_transport = hishel.CacheTransport(transport=httpx.HTTPTransport())\nclient = httpx.Client(transport=cache_transport)\nclient.get(\n    \"https://example.com/cacheable-endpoint\",\n    headers=[(\"Cache-Control\", \"no-store\"), (\"Cache-Control\", \"max-age=0\")]\n    ) # Ignores the cache\n</code></pre> <p>Since this can be cumbersome, <code>Hishel</code> also provides some \"syntactic sugar\" to accomplish the same result using <code>HTTPX</code> extensions:</p> <p><pre><code>import hishel\nimport httpx\n\n# With the clients\nclient = hishel.CacheClient()\nclient.get(\"https://example.com/cacheable-endpoint\", extensions={\"cache_disabled\": True}) # Ignores the cache\n\n# With the transport\ncache_transport = hishel.CacheTransport(transport=httpx.HTTPTransport())\nclient = httpx.Client(transport=cache_transport)\nclient.get(\"https://example.com/cacheable-endpoint\", extensions={\"cache_disabled\": True}) # Ignores the cache\n</code></pre> Both of these are entirely equivalent to specifying the headers directly.</p>"},{"location":"advanced/controllers/","title":"Controllers","text":"<p><code>Hishel</code> provides the <code>Controllers</code>, which allow you to fully customize how the cache works at the specification level.</p> <p>You can choose which parts of RFC 9111 to ignore. For example, this is useful when you want to ensure that your client does not use stale responses even if they are acceptable from the server.</p>"},{"location":"advanced/controllers/#force-caching","title":"Force caching","text":"<p>If you only need to cache responses without validating the headers and following RFC9111 rules, simply set the <code>force_cache</code> property to true.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(force_cache=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>force_cache extension will always overwrite the controller's force_cache property.</p>"},{"location":"advanced/controllers/#cachable-http-methods","title":"Cachable HTTP methods","text":"<p>You can specify which HTTP methods <code>Hishel</code> should cache.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(cacheable_methods=[\"GET\", \"POST\"])\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p><code>Hishel</code> will only cache <code>GET</code> methods if the cachable methods are not explicitly specified.</p>"},{"location":"advanced/controllers/#cachable-status-codes","title":"Cachable status codes","text":"<p>If you only want to cache specific status codes, do so.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(cacheable_status_codes=[301, 308])\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>If the cachable status codes are not explicitly specified, <code>Hishel</code> will only cache status codes 200, 301, and 308.</p>"},{"location":"advanced/controllers/#allowing-heuristics","title":"Allowing heuristics","text":"<p>You can enable heuristics calculations, which are disabled by default.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(allow_heuristics=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p><code>Hishel</code> is very conservative about what status codes are permitted to be heuristically cacheable. When <code>allow_heuristics</code> is enabled, <code>Hishel</code> will only cache responses having status codes 200, 301, and 308. In contrast, RFC 9111 specifies that many more responses can be heuristically cacheable, specifically 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501.</p> <p>If you would prefer heuristic caching to the fullest extent permitted by RFC 9111, then pass <code>HEURISTICALLY_CACHEABLE_STATUS_CODES</code> to <code>cacheable_status_codes</code>:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(\n    allow_heuristics=True,\n    cacheable_status_codes=hishel.HEURISTICALLY_CACHEABLE_STATUS_CODES\n    )\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Tip</p> <p>If you're not familiar with <code>Heuristics Caching</code>, you can read about it in the specification.</p>"},{"location":"advanced/controllers/#preventing-caching-of-private-responses","title":"Preventing caching of private responses","text":"<p>If you want <code>Hishel</code> to act as a shared cache, you need to prevent it from caching responses with the <code>private</code> directive.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(cache_private=False)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>Servers may prohibit only some headers from being stored in a shared cache by sending a header such as <code>Cache-Control: private=set-cookie</code>. However, <code>Hishel</code> with <code>cache_private=False</code> will still not cache the response, at all.</p>"},{"location":"advanced/controllers/#allowing-stale-responses","title":"Allowing stale responses","text":"<p>Some servers allow the use of stale responses if they cannot be re-validated or the client is disconnected from the server. Clients MAY use stale responses in such cases, but this behavior is disabled by default in <code>Hishel</code>.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(allow_stale=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Tip</p> <p><code>Hishel</code> will attempt to use stale response only if the client is unable to connect to the server to make a request. You can enable stale responses to receive responses even if your internet connection is lost.</p>"},{"location":"advanced/controllers/#specifying-revalidation-behavior","title":"Specifying revalidation behavior","text":"<p>Responses are revalidated by default when they become stale; however, you can always revalidate the responses if you wish.</p> <p>Example:</p> <pre><code>import hishel\n\ncontroller = hishel.Controller(always_revalidate=True)\nclient = hishel.CacheClient(controller=controller)\n</code></pre> <p>Note</p> <p>Because we already have the response body in our cache, revalidation is very quick.</p>"},{"location":"advanced/controllers/#custom-cache-keys","title":"Custom cache keys","text":"<p>By default, <code>Hishel</code> generates cache keys as a hash of the request method and url. However, you can customize cache key creation by writing a function with the signature <code>Callable[[httpcore.Request], str]</code> and passing it to the controller.</p> <p>Example:</p> <pre><code>import hishel\nimport httpcore\nfrom hishel._utils import generate_key\n\ndef custom_key_generator(request: httpcore.Request, body: bytes):\n    key = generate_key(request, body)\n    method = request.method.decode()\n    host = request.url.host.decode()\n    return f\"{method}|{host}|{key}\"\n\ncontroller = hishel.Controller(key_generator=custom_key_generator)\nclient = hishel.CacheClient(controller=controller)\n\nclient.get(\"https://hishel.com\")\n</code></pre> <p>Instead of just the <code>hashed_value</code>, the key now has the format <code>method|host|hashed_value</code>.</p> <p>Note</p> <p>Cache keys are used to store responses in storages, such as filesystem storage, which will use the cache key to create a file with that value. You can write your own cache key implementation to have more meaningful file names and simplify cache monitoring.</p> BeforeAfter <pre><code>\ud83d\udcc1 root\n\u2514\u2500\u2574\ud83d\udcc1 .cache\n   \u2514\u2500\u2574\ud83d\udcc1 hishel\n      \u2514\u2500\u2574\ud83d\udcc4 41ebb4dd16761e94e2ee36b71e0d916e\n</code></pre> <pre><code>\ud83d\udcc1 root\n\u2514\u2500\u2574\ud83d\udcc1 .cache\n   \u2514\u2500\u2574\ud83d\udcc1 hishel\n      \u2514\u2500\u2574\ud83d\udcc4 GET|hishel.com|41ebb4dd16761e94e2ee36b71e0d916e\n</code></pre>"},{"location":"advanced/extensions/","title":"Extensions","text":"<p><code>HTTPX</code> provides an extension mechanism to allow additional information  to be added to requests and to be returned in responses. <code>hishel</code> makes use of these extensions to expose some additional cache-related options and metadata. These extensions are available from either the <code>hishel.CacheClient</code> /  <code>hishel.AsyncCacheClient</code> or a <code>httpx.Client</code> / <code>httpx.AsyncCacheClient</code> using a <code>hishel</code> transport.</p>"},{"location":"advanced/extensions/#request-extensions","title":"Request extensions","text":""},{"location":"advanced/extensions/#force_cache","title":"force_cache","text":"<p>If this extension is set to true, <code>Hishel</code> will cache the response even if response headers would otherwise prevent caching the response.</p> <p>For example, if the response has a <code>Cache-Control</code> header that contains a <code>no-store</code> directive, it will not cache the response unless the <code>force_cache</code> extension is set to true.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/uncachable-endpoint\", extensions={\"force_cache\": True})\n</code></pre> <p>Note</p> <p>You can configure this extension globally for the controller, rather than setting force_cache to True for each request.</p>"},{"location":"advanced/extensions/#cache_disabled","title":"cache_disabled","text":"<p>This extension temporarily disables the cache by passing appropriate RFC9111 headers to ignore cached responses and to not store incoming responses. For example:</p> <p><pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/cacheable-endpoint\", extensions={\"cache_disabled\": True})\n</code></pre> This feature is more fully documented in the User Guide</p>"},{"location":"advanced/extensions/#response-extensions","title":"Response extensions","text":""},{"location":"advanced/extensions/#from_cache","title":"from_cache","text":"<p>Every response from  will have a <code>from_cache</code> extension value that will be <code>True</code> when the response was retrieved from the cache, and <code>False</code> when the response was received over the network.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com\")\n&gt;&gt;&gt; response.extensions[\"from_cache\"]\nFalse\n&gt;&gt;&gt; response = client.get(\"https://www.example.com\")\n&gt;&gt;&gt; response.extensions[\"from_cache\"]\nTrue\n</code></pre>"},{"location":"advanced/extensions/#revalidated","title":"revalidated","text":"<p>Every response will have a <code>revalidated</code> extension that indicates whether the response has been revalidated or not.</p> <p>Note</p> <p>Note that a response could have <code>revalidated</code> set to <code>True</code> even when <code>from_cache</code> is set to <code>False</code>. This occurs when the cached entry has been updated and a new entry is downloaded during revalidation.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/endpoint_that_is_fresh\")\n&gt;&gt;&gt; response.extensions[\"revalidated\"]\nFalse\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/endpoint_that_is_stale\")\n&gt;&gt;&gt; response.extensions[\"revalidated\"]\nTrue\n</code></pre>"},{"location":"advanced/extensions/#cache_metadata","title":"cache_metadata","text":"<p>If <code>from_cache</code> is <code>True</code>, the response will also include a <code>cache_metadata</code> extension with additional information about  the response retrieved from the cache. If <code>from_cache</code> is <code>False</code>, then <code>cache_metadata</code> will not be present in the response extensions.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/cacheable-endpoint\")\n&gt;&gt;&gt; response.extensions\n{\n    ... # other extensions\n    \"from_cache\": False\n}\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/cacheable-endpoint\")\n&gt;&gt;&gt; response.extensions\n{\n    ... # other extensions\n    \"from_cache\": True\n    \"cache_metadata\" : {\n        \"cache_key': '1a4c648c9a61adf939eef934a73e0cbe',\n        'created_at': datetime.datetime(2020, 1, 1, 0, 0, 0),\n        'number_of_uses': 1,\n    }\n}\n</code></pre>"},{"location":"advanced/http_headers/","title":"HTTP Headers","text":"<p>You can use the request <code>Cache-Control</code> directives defined in RFC 9111 to make the cache behavior more explicit in some situations.</p>"},{"location":"advanced/http_headers/#only-if-cached","title":"only-if-cached","text":"<p>If this directive is present in the request headers, the cache should either use the cached response or return the 504 status code.</p> <p>Note</p> <p>It is guaranteed that the client will not make any requests; instead, it will try to find a response from the cache that can be used for this request.</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; \n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; response = client.get(\"https://example.com\", headers=[(\"Cache-Control\", \"only-if-cached\")])\n&gt;&gt;&gt; response\n&lt;Response [504 Gateway Timeout]&gt;\n</code></pre> <p>or</p> <pre><code>&gt;&gt;&gt; import hishel\n&gt;&gt;&gt; \n&gt;&gt;&gt; client = hishel.CacheClient()\n&gt;&gt;&gt; client.get(\"https://google.com\")  # will cache\n&gt;&gt;&gt; response = client.get(\"https://google.com\", headers=[(\"Cache-Control\", \"only-if-cached\")])\n&gt;&gt;&gt; response\n&lt;Response [301 Moved Permanently]&gt;\n</code></pre>"},{"location":"advanced/http_headers/#max-age","title":"max-age","text":"<p>If this directive is present in the request headers, the cache should ignore responses that are older than the specified number.</p> <p>Example:</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"max-age=3600\")])\n</code></pre>"},{"location":"advanced/http_headers/#max-stale","title":"max-stale","text":"<p>If this directive is present in the request headers, the cache should ignore responses that have exceeded their freshness lifetime by more than the specified number of seconds.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"max-stale=3600\")])\n</code></pre>"},{"location":"advanced/http_headers/#min-fresh","title":"min-fresh","text":"<p>If this directive is present in the request headers, the cache should ignore responses that will not be fresh for at least the number of seconds specified.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"min-fresh=3600\")])\n</code></pre>"},{"location":"advanced/http_headers/#no-cache","title":"no-cache","text":"<p>If this directive is present in the request headers, the cache should not use the response to this request unless it has been validated.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"no-cache\")])\n</code></pre>"},{"location":"advanced/http_headers/#no-store","title":"no-store","text":"<p>If this directive is present in the request headers, the cache should not save the response to this request.</p> <pre><code>import hishel\n\nclient = hishel.CacheClient()\nclient.get(\"https://example.com\", headers=[(\"Cache-Control\", \"no-store\")])\n</code></pre>"},{"location":"advanced/logging/","title":"Logging","text":"<p>Logging is an important part of every application that helps developers better understand how the program operates. Hishel supports a variety of logs that can show you how the library impacts your program.</p> <p>Hishel will support several loggers for different parts of the program. Currently, we support only one logger called <code>hishel.controller</code>, which logs any event related to the cache. For example, it logs when a response is considered stale, when revalidation occurs, when a response is used from the cache, and more.</p>"},{"location":"advanced/logging/#controller-logs","title":"Controller logs","text":"<p>The controller is a part of the Hishel library that interprets the caching specification. It determines whether a response can be cached or retrieved from the cache.</p> <p>You can configure the controller logger for debugging purposes or to better understand how caching works. It can also be crucial when you're just starting out and want to understand why a particular response isn't being cached.</p> <p>For example, let's enable logging and see what gets logged when making an HTTP request to the Hishel documentation.</p> <pre><code>import logging\nimport hishel\n\nlogging.basicConfig(\n    level=logging.WARNING,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogging.getLogger(\"hishel.controller\").setLevel(logging.DEBUG)\n\nclient = hishel.CacheClient()\n\nresponse = client.get(\n    \"https://hishel.com\",\n)\n</code></pre> <p>Here is what Hishel will log for this program:</p> <pre><code>2024-09-30 16:32:34,799 - hishel.controller - DEBUG - Considering the resource located at https://hishel.com/ as cachable since it meets the criteria for being stored in the cache.\n</code></pre> <p>If you run this program a second time, you will receive the response from the cache because hishel.com sends all the necessary caching headers. So, for the second run, you will see a log entry about the successfully reused response.</p> <pre><code>2024-09-30 16:35:14,102 - hishel.controller - DEBUG - Considering the resource located at https://hishel.com/ as valid for cache use since it is fresh.\n</code></pre> <p>If we wait some time, the cached response will, of course, become stale. After some time, you can run this program again and see that the response needs to be revalidated from the server to obtain the most recent data. The logs could look like this:</p> <pre><code>2024-09-30 16:39:42,502 - hishel.controller - DEBUG - Considering the resource located at https://hishel.com/ as needing revalidation since it is not fresh.\n2024-09-30 16:39:42,502 - hishel.controller - DEBUG - Adding the 'If-Modified-Since' header with the value of 'Fri, 27 Sep 2024 07:42:28 GMT' to the request for the resource located at https://hishel.com/.\n</code></pre> <p>The controller will indicate not only that the response was cached but also why it was considered cacheable.</p> <p>Examples:</p> <ul> <li> <p>For permanent redirects <pre><code>2024-09-30 16:43:04,672 - hishel.controller - DEBUG - Considering the resource located at https://www.github.com/ as cachable since its status code is a permanent redirect.\n</code></pre></p> </li> <li> <p>When force_cache is enabled <pre><code>2024-09-30 16:45:10,468 - hishel.controller - DEBUG - Considering the resource located at https://www.google.com/ as valid for cache use since the request is forced to use the cache.\n</code></pre></p> </li> </ul> <p>Or when it's considered as not cachable</p> <pre><code>2024-09-30 17:02:24,961 - hishel.controller - DEBUG - Considering the resource located at https://www.python.org/ as not cachable since it does not contain any of the required cache directives.\n</code></pre> <p>Here you can find a full list of the controller logs. Note that this is the list of initial logs; any logs added later will not be updated in this list.</p>"},{"location":"advanced/new_storages/","title":"New Storages (Beta)","text":"<p><code>Hishel</code> has beta storages that are meant to be the default in the future, and the reason is the limitations of the current storages.</p> <p>Create an instance of a storage like this.</p> <pre><code>from hishel import SyncLmdbStorage, Request\n\nstorage = SyncLmdbStorage()\n</code></pre> <p>Create a new pair by calling the <code>create_pair</code> function, providing a key to group multiple pairs together, and the request you want to include in that pair.</p> <pre><code>incomplete_pair = storage.create_pair(\n    \"my_key\",\n    Request(\n        method=\"GET\",\n        url=\"https://example.org\"\n    )\n)\n</code></pre> <p>It returns an incomplete pair, which means you only have part of it (just the request). Later, if you receive a response and want to complete the pair, you can call <code>add_response</code> like this.</p> <pre><code>from hishel import Response\n\ncomplete_pair = storage.add_response(\n    incomplete_pair.id,\n    Response(\n        status_code=200,\n    ),\n)\n</code></pre> <p>Finally, get the grouped responses by calling the get_pairs function, which will return all the complete pairs stored under the particular key.</p> <pre><code>pairs = storage.get_pairs(\"test_key\")\n</code></pre>"},{"location":"advanced/serializers/","title":"Serializers","text":"<p>Serializers are a component of storages that simply serialize and de-serialize responses. Hishel will use JSONSerializer by default, but you can explicitly specify a serializer or even write your own.</p> <p>Example of the serialized responses:</p> JSONYaml <pre><code>{\n    \"response\": {\n        \"status\": 301,\n        \"headers\": [\n            [\n                \"Content-Length\",\n                \"0\"\n            ],\n            [\n                \"Location\",\n                \"https://github.com/\"\n            ]\n        ],\n        \"content\": \"\",\n        \"extensions\": {\n            \"http_version\": \"HTTP/1.1\",\n            \"reason_phrase\": \"Moved Permanently\"\n        }\n    },\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"https://www.github.com/\",\n        \"headers\": [\n            [\n                \"Host\",\n                \"www.github.com\"\n            ],\n            [\n                \"Accept\",\n                \"*/*\"\n            ],\n            [\n                \"Accept-Encoding\",\n                \"gzip, deflate\"\n            ],\n            [\n                \"Connection\",\n                \"keep-alive\"\n            ],\n            [\n                \"User-Agent\",\n                \"python-httpx/0.24.1\"\n            ]\n        ],\n        \"extensions\": {\n            \"timeout\": {\n                \"connect\": 5.0,\n                \"read\": 5.0,\n                \"write\": 5.0,\n                \"pool\": 5.0\n            }\n        }\n    },\n    \"metadata\": {\n        \"cache_key\": \"71b46af84732856e5c16d503b655fcd0\",\n        \"number_of_uses\": 0,\n        \"created_at\": \"Mon, 21 Aug 2023 05:22:20 GMT\"\n    }\n}\n</code></pre> <pre><code>response:\n  status: 301\n  headers:\n  - - Content-Length\n    - '0'\n  - - Location\n    - https://github.com/\n  content: ''\n  extensions:\n    http_version: HTTP/1.1\n    reason_phrase: Moved Permanently\nrequest:\n  method: GET\n  url: https://www.github.com/\n  headers:\n  - - Host\n    - www.github.com\n  - - Accept\n    - '*/*'\n  - - Accept-Encoding\n    - gzip, deflate\n  - - Connection\n    - keep-alive\n  - - User-Agent\n    - python-httpx/0.24.1\n  extensions:\n    timeout:\n      connect: 5.0\n      read: 5.0\n      write: 5.0\n      pool: 5.0\nmetadata:\n  cache_key: 71b46af84732856e5c16d503b655fcd0\n  number_of_uses: 0\n  created_at: Mon, 21 Aug 2023 05:22:20 GMT\n</code></pre>"},{"location":"advanced/serializers/#jsonserializer","title":"JSONSerializer","text":"<p>Example: <pre><code>import hishel\n\nserializer = hishel.JSONSerializer()\nstorage = hishel.FileStorage(serializer=serializer)\n</code></pre></p> <p>Because serializers are supported by all of the built-in <code>hishel</code> storages, you can pass serializers to any of them.</p> <p>Example: <pre><code>import hishel\n\nserializer = hishel.JSONSerializer()\nstorage = hishel.RedisStorage(serializer=serializer)\n</code></pre></p>"},{"location":"advanced/serializers/#yamlserizlier","title":"YAMLSerizlier","text":"<p>Example: <pre><code>import hishel\n\nserializer = hishel.YAMLSerializer()\nstorage = hishel.FileStorage(serializer=serializer)\n</code></pre></p> <p>Note</p> <p>Make sure <code>Hishel</code> has the yaml extension installed if you want to use the <code>YAMLSerializer</code>. <pre><code>$ pip install hishel[yaml]\n</code></pre></p>"},{"location":"advanced/serializers/#pickleserializer","title":"PickleSerializer","text":"<p>Example: <pre><code>import hishel\n\nserializer = hishel.PickleSerializer()\nstorage = hishel.FileStorage(serializer=serializer)\n</code></pre></p>"},{"location":"advanced/specification/","title":"Specification (Beta)","text":""},{"location":"advanced/specification/#event-driven-state-machine-usage","title":"Event-Driven State Machine Usage","text":"<p>Hishel provides a sans-I/O implementation of the caching specification (RFC 9111), so you can plug in your own I/O\u2014whether on the client or server side\u2014to enable caching that follows the specification rules.</p> <p>There\u2019s a fully typed state machine that tells you what to do next. Here\u2019s what it looks like:</p> <p>The state machine exposes the logic of RFC9111 as a series of states and transitions. You are responsible for all I/O (network, storage, etc.), while the state machine tells you what to do next.</p> <p>This design allows you to build HTTP caches that are correct, testable, and decoupled from any particular I/O or framework.</p> <pre><code>graph LR\n  IdleClient --&gt; CacheMiss;\n  IdleClient --&gt; PartialUpdate;\n\n  PartialUpdate --&gt; CacheMiss;\n  PartialUpdate --&gt; FromCache;\n  PartialUpdate --&gt; NeedRevalidation;\n\n  CacheMiss --&gt; StoreAndUse;\n  CacheMiss --&gt; CouldNotBeStored;\n\n  NeedRevalidation --&gt; NeedToBeUpdated;\n  NeedRevalidation --&gt; CacheMiss;</code></pre> <p>As a client, start with an idle state and check the next method\u2019s signature to understand what comes next.</p> <pre><code>from hishel import create_idle_state\n\nstate = create_idle_state(\"client\")  # client or server (server still in development)\n\n# signature will look like:\n#   (method) def next(\n#       request: Request,\n#       associated_pairs: list[CompletePair]\n#  )  -&gt; (CacheMiss | FromCache | NeedRevalidation)\nnext_state = state.next(...)\n</code></pre> <p>In this example, <code>next_state</code> will be one of <code>CacheMiss</code>, <code>FromCache</code>, or <code>NeedRevalidation</code>, each exposing the appropriate signature for its next method.</p>"},{"location":"advanced/specification/#states","title":"States","text":""},{"location":"advanced/specification/#idleclient","title":"IdleClient","text":"<p>This represents the state of an idle client that wants to reuse any stored responses whenever possible. The transition from this state follows the logic described in section 4, Constructing Responses from Caches, of RFC 9111.</p> <p>Here\u2019s a simple example:</p> <pre><code>from hishel import (\n    CacheMiss,\n    FromCache,\n    NeedRevalidation,\n    Request,\n    UpdatePartials,\n    create_idle_state,\n)\n\nstate = create_idle_state(\"client\")\n\nnext_state: (\n    UpdatePartials[CacheMiss | FromCache | NeedRevalidation] | CacheMiss\n) = state.next(\n    Request(\n        method=\"GET\",\n        url=\"https://example.com/resource\",\n    ),\n    associated_pairs=[],\n)\n</code></pre> <p>To move from the <code>IdleClient</code> state, we need the <code>request</code> for which we want to find a cached response, along with the list of <code>associated_pairs</code> that we have stored earlier and could potentially use for this request.</p>"},{"location":"advanced/specification/#cachemiss","title":"CacheMiss","text":"<p><code>CacheMiss</code> is the state that indicates the <code>associated_pairs</code> could not be used at all, even with revalidation. The transition logic for this state is described in section 3, Storing Responses in Caches, of RFC9111. Here is a simple example of its usage:</p> <pre><code>from hishel import (\n    CacheMiss,\n    CacheOptions,\n    CompletePair,\n    CouldNotBeStored,\n    Response,\n    StoreAndUse,\n)\nfrom hishel._core.models import Request\n\ncache_miss = CacheMiss(\n    request=Request(\n        method=\"GET\",\n        url=\"https://example.com/resource\",\n    ),  # Request that missed the cache\n    options=CacheOptions(),\n)\n\nnext_state: StoreAndUse | CouldNotBeStored = cache_miss.next(\n    pair=CompletePair.create(\n        response=Response(\n            status_code=200,\n        ),\n        request=Request(\n            method=\"GET\",\n            url=\"https://example.com\",\n        ),\n    )\n)\n</code></pre>"},{"location":"advanced/specification/#partialupdate","title":"PartialUpdate","text":"<p><code>PartialUpdate</code> is an intermediary state that indicates which responses from <code>associated_pairs</code> provided earlier can be merged into a single one. The transition logic for this state is described in section 3.4, Combining Partial Content, of RFC9111.</p>"},{"location":"advanced/specification/#needrevalidation","title":"NeedRevalidation","text":"<p><code>NeedRevalidation</code> indicates that there are responses that could be used for the request, but they must be revalidated first. The transition logic for this state is described in section 4.3, Validation, of RFC9111.</p>"},{"location":"advanced/specification/#fromcache","title":"FromCache","text":"<p>The <code>FromCache</code> state indicates that an <code>associated_pair</code> was found for the request and can be used without revalidation.</p>"},{"location":"advanced/specification/#needtobeupdated","title":"NeedToBeUpdated","text":"<p><code>NeedToBeUpdated</code> is a state very similar to <code>FromCache</code>. Like <code>FromCache</code>, it indicates that a response can be used for your request, but it also signals that some stored responses need to be refreshed.</p>"},{"location":"advanced/specification/#couldnotbestored","title":"CouldNotBeStored","text":"<p><code>CouldNotBeStored</code> is a state that indicates the response you are trying to store could not be saved and should be skipped.</p>"},{"location":"advanced/specification/#storeanduse","title":"StoreAndUse","text":"<p><code>StoreAndUse</code> is the opposite of <code>CouldNotBeStored</code>. It indicates that the response is storable according to the specification, so you can store it and then use it.</p>"},{"location":"advanced/specification/#configuration","title":"Configuration","text":"<p>You can pass an options parameter to any state to control how it behaves in certain situations. This was primarily added to allow configuration for cases where the RFC does not explicitly specify the behavior. In some places, the RFC might say that a cache MIGHT do something; the <code>options</code> parameter lets you define how to handle such cases.</p> <p>Import the CacheOptions class and pass it to the State, like so:</p> <pre><code>from hishel import IdleClient, CacheOptions\n\nstate = IdleClient(\n  options=CacheOptions(\n    allow_stale=True\n  )\n)\n</code></pre>"},{"location":"advanced/storages/","title":"Storages","text":"<p>When using <code>Hishel</code>, you have complete control over the configuration of how the responses should be stored. You can select the serializer and storage on your own.</p> <p>This section contains examples of how to use the storages.</p>"},{"location":"advanced/storages/#filesystem-storage","title":"Filesystem storage","text":"<p>To explicitly specify the storage, we should create it first and pass it to the HTTP caching class.</p> <p>Example: <pre><code>import hishel\n\nstorage = hishel.FileStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre></p> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.FileStorage()\ntransport = hishel.CacheTransport(transport=httpx.HTTPTransport(), storage=storage)\n</code></pre> <p>Here's how the filesystem storage looks:</p> <pre><code>\ud83d\udcc1 root\n\u2514\u2500\u2574\ud83d\udcc1 .cache\n   \u2514\u2500\u2574\ud83d\udcc1 hishel\n      \u251c\u2500\u2574\ud83d\udcc4 GET|github.com|a9022e44881123781045f6fadf37a8b1\n      \u251c\u2500\u2574\ud83d\udcc4 GET|www.google.com|8bfc7fffcfd5f2b8e3485d0cc7450c98\n      \u251c\u2500\u2574\ud83d\udcc4 GET|www.python-httpx.org|5f004f4f08bd774c4bc4b270a0ca542e\n      \u2514\u2500\u2574\ud83d\udcc4 GET|hishel.com|41ebb4dd16761e94e2ee36b71e0d916e\n</code></pre> <p>Note</p> <p>Note that by default, file names are just the hashed value, without the http method or hostname; to have meaningful names, see custom cache keys.</p>"},{"location":"advanced/storages/#storage-directory","title":"Storage directory","text":"<p>If the responses are saved in the filesystem, there should be a directory that contains our responses.</p> <p>By default it's <code>.cache/hishel</code>.</p> <p>If you want to change the directory, do so as follows.</p> <pre><code>import hishel\n\nstorage = hishel.FileStorage(base_path=\"/home/test/my_cache_dir\")\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-filestorage","title":"Responses ttl in FileStorage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.FileStorage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#check-ttl-every","title":"Check ttl every","text":"<p>In order to avoid excessive memory utilization, <code>Hishel</code> must periodically clean the old responses, or responses that are not being used and should be deleted from the cache. It clears the cache by default every minute, but you may change the interval directly with the <code>check_ttl_every</code> argument.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.FileStorage(check_ttl_every=600) # check every 600s (10m) \n</code></pre>"},{"location":"advanced/storages/#in-memory-storage","title":"In-memory storage","text":"<p><code>Hishel</code> has an in-memory cache that can be used when you don't need the cache to be persistent.</p> <p>You should understand that in memory cache means that all cached responses are stored in RAM, so you should be cautious and possibly configure the cache's maximum size to avoid wasting RAM.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.InMemoryStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.InMemoryStorage()\nclient = hishel.CacheTransport(transport=httpx.HTTPTransport(), storage=storage)\n</code></pre>"},{"location":"advanced/storages/#set-the-maximum-capacity","title":"Set the maximum capacity","text":"<p>You can also specify the maximum number of requests that the storage can cache. </p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.InMemoryStorage(capacity=64)\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Note</p> <p>When the number of responses exceeds the cache's capacity, Hishel employs the LFU algorithm to remove some of the responses. </p>"},{"location":"advanced/storages/#redis-storage","title":"Redis storage","text":"<p><code>Hishel</code> includes built-in redis support, allowing you to store your responses in redis.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.RedisStorage()\nclient = hishel.CacheTransport(transport=httpx.HTTPTransport(), storage=storage)\n</code></pre>"},{"location":"advanced/storages/#custom-redis-client","title":"Custom redis client","text":"<p>If you need to connect somewhere other than localhost, this is how you can do it.</p> <pre><code>import hishel\nimport redis\n\nstorage = hishel.RedisStorage(\n    client=redis.Redis(\n        host=\"192.168.0.85\",\n        port=8081,\n    )\n)\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-redisstorage","title":"Responses ttl in RedisStorage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.RedisStorage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#sqlite-storage","title":"SQLite storage","text":"<p><code>Hishel</code> includes built-in sqlite support, allowing you to store your responses in sqlite database.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.SQLiteStorage()\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports:</p> <pre><code>import hishel\nimport httpx\n\nstorage = hishel.SQLiteStorage()\nclient = hishel.CacheTransport(transport=httpx.HTTPTransport())\n</code></pre> <p>Note</p> <p>Make sure <code>Hishel</code> has the sqlite extension installed if you want to use the <code>AsyncSQLiteStorage</code>. <pre><code>$ pip install hishel[sqlite]\n</code></pre></p>"},{"location":"advanced/storages/#sqlite-custom-connection","title":"Sqlite custom connection","text":"<p>If you want more control over the underlying sqlite connection, you can explicitly pass it.</p> <pre><code>import hishel\nimport sqlite3\n\nclient = hishel.CacheClient(\n    storage=hishel.SQLiteStorage(connection=sqlite3.connect(\"my_db_path\", timeout=5))\n)\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-sqlitestorage","title":"Responses ttl in SQLiteStorage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.SQLiteStorage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#aws-s3-storage","title":"AWS S3 storage","text":"<p><code>Hishel</code> has built-in AWS S3 support, allowing users to store responses in the cloud.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.S3Storage(bucket_name=\"cached_responses\")\nclient = hishel.CacheClient(storage=storage)\n</code></pre> <p>Or if you are using Transports <pre><code>import httpx\nimport hishel\n\nstorage = hishel.S3Storage(bucket_name=\"cached_responses\")\ntransport = hishel.CacheTransport(httpx.HTTPTransport(), storage=storage)\n</code></pre></p>"},{"location":"advanced/storages/#custom-aws-s3-client","title":"Custom AWS S3 client","text":"<p>If you want to manually configure the client instance, pass it to Hishel.</p> <pre><code>import hishel\nimport boto3\n\ns3_client = boto3.client('s3')\n\nstorage = hishel.S3Storage(bucket_name=\"cached_responses\", client=s3_client)\nclient = hishel.CacheClient(storage=storage)\n</code></pre>"},{"location":"advanced/storages/#responses-ttl-in-s3storage","title":"Responses ttl in S3Storage","text":"<p>You can explicitly specify the ttl for stored responses in this manner.</p> <pre><code>import hishel\n\nstorage = hishel.S3Storage(ttl=3600)\n</code></pre> <p>If you do this, <code>Hishel</code> will delete any stored responses whose ttl has expired. In this example, the stored responses were limited to 1 hour.</p> <p>The default <code>ttl</code> is <code>None</code>, which means that responses will be stored until the controller decides to remove them.</p>"},{"location":"advanced/storages/#check-ttl-every_1","title":"Check ttl every","text":"<p>In order to avoid excessive memory utilization, <code>Hishel</code> must periodically clean the old responses, or responses that are not being used and should be deleted from the cache. It clears the cache by default every minute, but you may change the interval directly with the <code>check_ttl_every</code> argument.</p> <p>Example:</p> <pre><code>import hishel\n\nstorage = hishel.S3Storage(check_ttl_every=600) # check every 600s (10m) \n</code></pre>"},{"location":"examples/fastapi/","title":"FastAPI","text":"<p>Many <code>FastAPI</code> users use <code>HTTPX</code> as a modern and very fast HTTP client, which also supports async/await syntax like FastAPI does.</p> <p>Here is an example of how <code>HTTPX</code> can be used in <code>FastAPI</code>.</p> <pre><code>from fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom httpx import Limits\n\napp = FastAPI()\nclient = AsyncClient(limits=Limits(max_connections=1000))\n\n@app.get(\"/\")\nasync def main():\n    response = await client.get('https://www.encode.io')\n    return response.status_code\n</code></pre> <p>Now let's do some load testing using the popular load testing tool Locust.</p> <p>Here are the test results:</p> <p> </p> <p>Despite the fact that we use async/await, we got only \u00b170 RPS.</p> <p>Now let's change the <code>httpx.AsyncClient</code> to <code>hishel.AsyncCacheClient</code> and do the same tests again.</p> <pre><code>from fastapi import FastAPI\nfrom hishel import AsyncCacheClient\nfrom httpx import Limits\n\napp = FastAPI()\nclient = AsyncCacheClient(limits=Limits(max_connections=1000))\n\n@app.get(\"/\")\nasync def main():\n    response = await client.get('https://www.encode.io')\n    return response.status_code\n</code></pre> <p>Here are the test results:</p> <p> </p> <p>Now we have more than 365+ RPS using the power of HTTP caching.</p>"},{"location":"examples/flask/","title":"Flask","text":"<p>As a <code>Flask</code> user, you can use the power of <code>HTTPX</code> using its synchronous interface.</p> <p>Here is a simple example:</p> <pre><code>from flask import Flask\nfrom httpx import Client\nfrom httpx import Limits\n\napp = Flask(__name__)\nclient = Client(limits=Limits(max_connections=1000))\n\n@app.route(\"/\")\ndef main():\n    response = client.get('https://www.encode.io')\n    return str(response.status_code)\n</code></pre> <p>Now let's do some load testing using the popular load testing tool Locust.</p> <p>Here are the test results:</p> <p> </p> <p>We got only \u00b120 RPS, which is not very good.</p> <p>Now let's change the <code>httpx.Client</code> to <code>hishel.CacheClient</code> and do the same tests again.</p> <pre><code>from flask import Flask\nfrom hishel import CacheClient\nfrom httpx import Limits\n\napp = Flask(__name__)\nclient = CacheClient(limits=Limits(max_connections=1000))\n\n@app.route(\"/\")\ndef main():\n    response = client.get('https://www.encode.io')\n    return str(response.status_code)\n</code></pre> <p>Here are the test results:</p> <p> </p> <p>Now we have more than \u00b1800 RPS using the power of HTTP caching.</p>"},{"location":"examples/github/","title":"GitHub","text":"<p>On this page, we'll look at why HTTP caching is important when using GitHub APIs.</p> <p>Let's create a simple program that takes the name of a <code>GitHub</code> repository and displays the stars in real time.</p> <p>To use GitHub APIs, we first need an access token. See how to create a github token here.</p> <p>However, if we write a program that makes a large number of HTTP requests to the GItHub servers, we will be blocked for a period of time because github has rate limits in place to prevent overloading their servers.</p> <p>In such cases, APIs frequently provide HTTP caching functionality, which we can use to retrieve the response from the local cache or make a new request if the data on the server has changed.</p> <p>To ensure that cached responses are not counted, we should also display the rate limit.</p> <pre><code>import os\nfrom time import sleep\n\nimport hishel\n\nTOKEN = os.getenv(\"TOKEN\")\n\nclient = hishel.CacheClient(\n    headers={\n        \"Authorization\": f\"Bearer {TOKEN}\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n        \"Accept\": \"application/vnd.github+json\",\n    },\n)\n\nrepo = input(\"Enter repo name: \")  # example: \"karpetrosyan/hishel\"\norganization, repo = repo.split(\"/\")\n\n\nwhile True:\n    stars_response = client.get(f\"https://api.github.com/repos/{organization}/{repo}\")\n    stars = stars_response.json()[\"stargazers_count\"]\n\n    rate_response = client.get(\"https://api.github.com/rate_limit\")\n    remaining = rate_response.json()[\"rate\"][\"remaining\"]\n\n    print(f\"\\rStars: {stars} Remaining rate limit: {remaining}\", end=\"\")\n    sleep(1)\n</code></pre> <p>Change <code>hishel.CacheClient</code> to <code>httpx.Client</code> to see how quickly you are wasting your rate limits!</p> <p>When <code>HTTPX</code> makes a real request in each iteration, <code>Hishel</code> consumes the rate limit only once and stores the response in the local cache.</p> <p>Also, keep in mind that when the stars count is updated, it will not be displayed immediately when using <code>Hishel</code> because it uses the cached response; instead, it will wait until the local response is considered stale before re-validating that response.</p> <p>Because <code>GitHub</code> sends a header indicating that this response has a maximum lifespan of 60 seconds, you will see the updated stars count after 60 seconds.</p> <p>Here is what that header looks like: <pre><code>Cache-Control: private, max-age=60, s-maxage=60\n</code></pre></p> <p>Anyway, if you want to see the update without any delay, you can explicitly tell the <code>Hishel</code> that you want to always re-validate the response before using it, which is also free and doesn't have a rate limit!</p> <p>Example:</p> <pre><code>client = hishel.CacheClient(\n    headers={\n        \"Authorization\": f\"Bearer {TOKEN}\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n        \"Accept\": \"application/vnd.github+json\",\n    },\n    controller=hishel.Controller(always_revalidate=True)\n)\n</code></pre>"}]}